#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 2010 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

Usage#
deploy.command=Implementar um aplicativo no servidor de aplicativos
deploy.command.usagetext=deploy\n\t[--target[=<target(default:server)>]]\n\t[--virtualservers <virtual_servers>] [--contextroot <context_root>]\n\t[--force[=<force(default:false)>]]\n\t[--precompilejsp[=<precompilejsp(default:false)>]]\n\t[--verify[=<verify(default:false)>]] [--name <component_name>]\n\t[--upload[=<upload(default:false)>]] [--retrieve <local_dirpath>]\n\t[--dbvendorname <dbvendorname>]\n\t[--createtables[=createtables(default:false)>] |\n\t --dropandcreatetables[=<dropandcreatetables(default:false)>]]\n\t[--uniquetablenames[=<uniquetablenames(default:false)>]]\n\t[--deploymentplan <deployment_plan>]\n\t[--enabled[=<enabled(default:true)>]]\n\t[--availabilityenabled[=<availabilityenabled(default:false)>]]\n\t[--lbenabled[=<lbenabled(default:true)>]]\n\t[--asyncreplication[=<asyncreplication(default:true)>]]\n\t[--keepstate[=<keepstate(default:false)>]]\n\t[--generatermistubs[=<generatermistubs(default:false)>]]\n\t[--libraries jar_file[,jar_file*]] [--type <pkg-type>]\n\t[--properties (name=value)[:name=value]*]\n\t[-?|--help[=<help(default:false)>]] file_archive | filepath
deploy.command.path=Caminho para o arquivo ou diret\u00f3rio a ser implementado
deploy.command.name=Nome para o aplicativo
deploy.command.contextroot=Context-root do aplicativo da Web.  Padroniza para o nome do arquivo sem a extens\u00e3o.
deploy.command.libraries=Uma lista separada por v\u00edrgulas de arquivos JAR da biblioteca.  
deploy.command.force=Se verdadeiro, o aplicativo \u00e9 reimplementado.  Padroniza para falso.
deploy.command.precompilejsp=Se verdadeiro, os JSPs s\u00e3o compilados durante a implementa\u00e7\u00e3o. Padroniza para falso.
deploy.command.verify=Se verdadeiro, a sintaxe e sem\u00e2ntica do descritor da implementa\u00e7\u00e3o s\u00e3o verificadas.  Padroniza para falso.
deploy.command.retrieve=Recupera o arquivo client stub JAR da m\u00e1quina do servidor para o diret\u00f3rio local.
deploy.command.dbvendorname=Nome do fornecedor do banco de dados para o qual as tabelas s\u00e3o criadas.
deploy.command.createtables=Cria tabelas na implementa\u00e7\u00e3o de um aplicativo com beans CMP n\u00e3o mapeados.
deploy.command.dropandcreatetables=Se verdadeiro, quando o aplicativo \u00e9 reimplementado, as tabelas criadas pela implementa\u00e7\u00e3o anterior s\u00e3o descartadas antes da cria\u00e7\u00e3o das novas tabelas.
deploy.command.uniquetablenames=Garante nomes \u00fanicos de tabelas para todos os beans e resultados no hashcode adicionado aos nomes das tabelas.
deploy.command.deploymentplan=Obt\u00e9m o plano de implementa\u00e7\u00e3o, que \u00e9 um JAR contendo descritores espec\u00edficos da Sun, e o implementa.
deploy.command.enabled=Se verdadeiro, permite que os usu\u00e1rios acessem o aplicativo.  Padroniza para verdadeiro.
deploy.command.generatermistubs=Se verdadeiro, os stubs RMI-IIOP s\u00e3o gerados e colocados no client.jar.  Padroniza para falso.
deploy.command.availabilityenabled=Se verdadeiro, a alta disponibilidade \u00e9 ativada para o ponto de verifica\u00e7\u00e3o e passiva\u00e7\u00e3o potencial do SFSB.  V\u00e1lido apenas para dom\u00ednios configurados para suportar o cluster.
deploy.command.target=Especifique o destino para implementar o aplicativo.
deploy.command.properties=Especifique as propriedades como pares nome/valor que ser\u00e3o passados para o execut\u00e1vel do aplicativo.
deploy.nocontainer=Nenhum servi\u00e7o de recipiente registrado, conclu\u00eddo...
application.alreadyreg.redeploy=O aplicativo denominado {0} j\u00e1 est\u00e1 implantado. Especifique que a reimplementa\u00e7\u00e3o precisa ser for\u00e7ada ou reimplemente o aplicativo. Ou se for uma nova implementa\u00e7\u00e3o, escolha outro nome. 
deploy.command.success=Aplicativo implementado com o nome {0}.
deploy.command.successwithwarning=O aplicativo foi implementado com sucesso com o nome {0} e com os seguintes avisos:
deploy.unknownarchivetype=O tipo de arquivo {0} n\u00e3o foi reconhecido
deploy.unknowntype={0} n\u00e3o \u00e9 um tipo de arquivo reconhecido
deploy.unknowncontainer={0} n\u00e3o \u00e9 um recipiente reconhecido 
deploy.unknownarchiveformat=O formato do arquivo n\u00e3o foi reconhecido
deploy.errorexpandingjar=Erro ao expandir o arquivo jar
deploy.cannotcreateexpansiondir=Erro ao criar o diret\u00f3rio para a expans\u00e3o jar {0}; continuando
deploy.errorclosingarchive=Erro ao fechar o artefato implement\u00e1vel {0}
deploy.invalidpropertyformat=A propriedade da implementa\u00e7\u00e3o n\u00e3o segue o formato NOME=VALOR: {0}
deploy.errOpeningArtifact=Erro ao abrir o artefato implement\u00e1vel
deploy.errDuringDepl=Erro durante a implementa\u00e7\u00e3o: {0}. Consulte o server.log para obter mais detalhes
deploy.errClosingArtifact=Erro ao fechar o artefato implement\u00e1vel {0}
deploy.done={0} foi implementado com \u00eaxito em {1} milisegundos.
deploy.failverifier=Alguns testes de verifica\u00e7\u00e3o falharam para o determinado aplicativo. Cancelando a implementa\u00e7\u00e3o. Consulte o server.log para obter mais detalhes
deploy.remoteDirDeployChecksumMismatch=Os arquivos implementados no diret\u00f3rio em {0} nesta inst\u00e2ncia s\u00e3o diferentes dos acess\u00edveis no mesmo caminho do servidor admin de dom\u00ednio.  O conte\u00fado precisa coincidir ou arquivos diferentes ser\u00e3o implementados em diferentes inst\u00e2ncias.
download.errDownloading=Erro ao baixar os arquivos gerados
compat.value.not.supported=AVISO: {0} n\u00e3o \u00e9 um valor suportado para a propriedade de compatibilidade. O valor atual suportado para a propriedade \u00e9 v2. Ignorando a propriedade.
#
undeploy.command=Cancelar a implementa\u00e7\u00e3o de um aplicativo anteriormente implementado do servidor de aplicativos
undeploy.command.usagetext=undeploy\n\t[--target[=<target(default:server)>]]\n\t[--droptables[=<droptables(default:false)>]]\n\t[--cascade[=<cascade(default:false)>]]\n\t[-?|--help[=<help(default:false)>]] name
undeploy.command.name=Nome do aplicativo implementado
undeploy.command.target=Especifique o destino para cancelar a implementa\u00e7\u00e3o do aplicativo.
undeploy.command.success={0} implementa\u00e7\u00e3o cancelada com sucesso
undeploy.contextcreation.failed =N\u00e3o \u00e9 poss\u00edvel criar o contexto para o cancelamento da implementa\u00e7\u00e3o: {0}

#
deploydir.command=implementa um formato explodido do arquivo do aplicativo. Este comando \u00e9 obsoleto.  Utilize o comando implementar.  Consulte 'deploy --help' para obter uma descri\u00e7\u00e3o completa do comando implementar.
deploydir.command.usagetext=deploydir\n\t[--target[=<target(default:server)>]]\n\t[--virtualservers <virtual_servers>] [--contextroot <context_root>]\n\t[--force[=<force(default:false)>]]\n\t[--precompilejsp[=<precompilejsp(default:false)>]]\n\t[--verify[=<verify(default:false)>]] [--name <component_name>]\n\t[--retrieve <local_dirpath>]\n\t[--dbvendorname <dbvendorname>]\n\t[--createtables[=createtables(default:false)>] |\n\t --dropandcreatetables[=<dropandcreatetables(default:false)>]]\n\t[--uniquetablenames[=<uniquetablenames(default:false)>]]\n\t[--deploymentplan <deployment_plan>]\n\t[--enabled[=<enabled(default:true)>]]\n\t[--availabilityenabled[=<availabilityenabled(default:false)>]]\n\t[--lbenabled[=<lbenabled(default:true)>]]\n\t[--asyncreplication[=<asyncreplication(default:true)>]]\n\t[--keepstate[=<keepstate(default:false)>]]\n\t[--generatermistubs[=<generatermistubs(default:false)>]]\n\t[--libraries jar_file[,jar_file*]] [--type <pkg-type>]\n\t[--properties (name=value)[:name=value]*]\n\t[-?|--help[=<help(default:false)>]] dirpath

#
redeploy.command=Reimplementa um aplicativo anteriormente implementado.  
redeploy.command.name=Nome do aplicativo a ser reimplementado . \u00c9 uma op\u00e7\u00e3o obrigat\u00f3ria.
redeploy.command.path=Caminho para o arquivo ou diret\u00f3rio a ser implementado.
redeploy.command.invalid.path=N\u00e3o \u00e9 poss\u00edvel determinar o caminho do aplicativo.
redeploy.command.cannot.redeploy=N\u00e3o \u00e9 poss\u00edvel reimplementar o aplicativo, {0} sem especificar o operando do caminho.
redeploy.command.success={0} reimplementado com sucesso
redeploy.command.usagetext=redeploy\n\t[--target[=<target(default:server)>]]\n\t[--virtualservers <virtual_servers>] [--contextroot <context_root>]\n\t[--precompilejsp[=<precompilejsp(default:false)>]]\n\t[--verify[=<verify(default:false)>]] --name <component_name>\n\t[--upload[=<upload(default:false)>]] [--retrieve <local_dirpath>]\n\t[--dbvendorname <dbvendorname>]\n\t[--createtables[=createtables(default:false)>] |\n\t --dropandcreatetables[=<dropandcreatetables(default:false)>]]\n\t[--uniquetablenames[=<uniquetablenames(default:false)>]]\n\t[--deploymentplan <deployment_plan>]\n\t[--enabled[=<enabled(default:true)>]]\n\t[--availabilityenabled[=<availabilityenabled(default:false)>]]\n\t[--lbenabled[=<lbenabled(default:true)>]]\n\t[--asyncreplication[=<asyncreplication(default:true)>]]\n\t[--keepstate[=<keepstate(default:false)>]]\n\t[--generatermistubs[=<generatermistubs(default:false)>]]\n\t[--libraries jar_file[,jar_file*]] [--type <pkg-type>]\n\t[--properties (name=value)[:name=value]*]\n\t[-?|--help[=<help(default:false)>]] [file_archive | filepath]

#
enable.command=Ativa o aplicativo
enable.command.target=Especifica o destino para o qual o aplicativo est\u00e1 sendo ativado.
enable.command.component=Nome do aplicativo a ser ativado.
enable.command.success={0} ativado com sucesso

#
disable.command=Desativa o aplicativo
disable.command.usagetext=disable\n\t[--target[=<target(default:server)>]]\n\t[-?|--help[=<help(default:false)>]] component
disable.command.component=Nome do aplicativo a ser desativado.
disable.command.success={0} desativado com sucesso
disable.command.failed={0} falha ao desativar

#
failToLoadOnInstance=Falha ao carregar o aplicativo na inst\u00e2ncia {0}. O aplicativo n\u00e3o ser\u00e1 corretamente executado. Corrija seu aplicativo e fa\u00e7a sua reimplementa\u00e7\u00e3o. \n{1}. Consulte o server.log para obter mais detalhes. 

#
list.components=Lista os aplicativos implementados pelo usu\u00e1rio.
list.components.type=Tipo do aplicativo a ser listado.  Os tipos aplic\u00e1veis s\u00e3o: aplicativo, ejb, web, conector e servi\u00e7o Web.  Caso nada seja especificado, todos os componentes ser\u00e3o listados.
list.components.success=Lista os componentes com sucesso.
list.components.command.invalid.type=Valor inv\u00e1lido da op\u00e7\u00e3o de tipo.
list.components.no.elements.to.list=Nada a listar.
list.applications.success=Lista os aplicativos com sucesso.
list.applications=Lista os aplicativos implementados pelo usu\u00e1rio.  Consulte 'list-applications --help' para obter uma lista de op\u00e7\u00f5es v\u00e1lidas.
list.applications.warning=AVISO: Este comando ser\u00e1 removido.  Utilize o comando list-components.
list.applications.verbose.enabled=ativado
list.applications.verbose.disabled=desativado

#
component.status=O status de {0} \u00e9 {1}.

# common strings
application.alreadyreg=O aplicativo denominado [{0}] j\u00e1 est\u00e1 implantado.
application.notreg=O aplicativo denominado [{0}] n\u00e3o est\u00e1 implantado.
lifecycle.alreadyreg=O m\u00f3dulo de ciclo de vida com o nome [{0}] j\u00e1 existe
lifecycle.notreg=O m\u00f3dulo de ciclo de vida com o nome [{0}] n\u00e3o existe
ref.not.referenced.target=O aplicativo {0} n\u00e3o est\u00e1 implantado neste destino [{1}]
lifecycle.not.referenced.target=O m\u00f3dulo de ciclo de vida {0} n\u00e3o est\u00e1 implantado neste destino [{1}]
virtualservers=Lista dos servidores virtuais aos quais aplicar o comando
fnf=Arquivo n\u00e3o encontrado: {0}
invalidconfig=Entradas inv\u00e1lidas no domain.xml entries, registre um bug
nocontainer=Nenhum servi\u00e7o de recipiente registrado, conclu\u00eddo...
unknownmoduletpe=Tipo de m\u00f3dulo n\u00e3o reconhecido

appref.already.exists=A refer\u00eancia do aplicativo {0} j\u00e1 existe no destino {1}.
appref.not.exists=O destino {1} n\u00e3o tem uma refer\u00eancia ao aplicativo {0}.


wildcard.not.allowed=AVISO: a express\u00e3o de vers\u00e3o est\u00e1 dispon\u00edvel somente com --enabled=false
