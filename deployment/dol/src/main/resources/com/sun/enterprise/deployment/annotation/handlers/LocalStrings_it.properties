#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 2010-2011 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

#EN enterprise.deployment.annotation.handlers.invalidaehandler=Invalid annotation symbol found for this type of class.
enterprise.deployment.annotation.handlers.invalidaehandler=Rilevato simbolo di annotazione non valido per questo tipo di classe.
#EN enterprise.deployment.annotation.handlers.cantfindmsglistenerintf=Cannot find message listener interface for bean class.
enterprise.deployment.annotation.handlers.cantfindmsglistenerintf=Impossibile trovare l'interfaccia listener messaggi per la classe di bean.
#EN enterprise.deployment.annotation.handlers.ambiguousimplementsclause=Implements clause for 3.x bean class {0} in {1} declares more than one potential business interface.  In this case, the @Remote and/or @Local annotations must be used to identify the business interfaces.
enterprise.deployment.annotation.handlers.ambiguousimplementsclause=La clausola Implements per la classe di bean 3.x {0} in {1} dichiara pi\u00F9 interfacce business potenziali. In questo caso, \u00E8 necessario usare le annotazioni @Remote e/o @Local per identificare le interfacce business.
#EN enterprise.deployment.annotation.handlers.ambiguousimplementsclausemdb=Implements clause for 3.x message-driven bean class {0} in {1} declares more than one potential message-listener interface.  In this case, the @MessageDriven.messageListenerInterface() attribute must be used to specify the message listener interface.
enterprise.deployment.annotation.handlers.ambiguousimplementsclausemdb=La clausola Implements per la classe di bean basati su messaggi 3.x {0} in {1} dichiara pi\u00F9 interfacce listener messaggi potenziali. In questo caso, \u00E8 necessario usare l''attributo @MessageDriven.messageListenerInterface() per specificare l''interfaccia listener messaggi.
#EN enterprise.deployment.annotation.handlers.invalidtypelevelejb=Invalid TYPE-level @EJB with name() = [{0}] and beanInterface = [{1}] in {2}.  Each TYPE-level @EJB must specify both name() and beanInterface().
enterprise.deployment.annotation.handlers.invalidtypelevelejb=TYPE-level @EJB non valido con name() = [{0}] e beanInterface = [{1}] in {2}. Ogni TYPE-level @EJB deve specificare sia name() che beanInterface().
#EN enterprise.deployment.annotation.handlers.invalidtypelevelresource=Invalid TYPE-level @Resource with name() = [{0}] and type = [{1}] in {2}. Each TYPE-level @Resource must specify both name() and type().
enterprise.deployment.annotation.handlers.invalidtypelevelresource=TYPE-level @Resource non valido con name() = [{0}] e tipo = [{1}] in {2}. Ogni TYPE-level @Resource deve specificare sia name() che type().
#EN enterprise.deployment.annotation.handlers.wrongejbtype=Wrong annotation symbol for ejb {1}
enterprise.deployment.annotation.handlers.wrongejbtype=Simbolo di annotazione errato per EJB {1}
#EN enterprise.deployment.annotation.handlers.ejbclsmismatch=<ejb-class> value [{0}] in ejb-jar.xml for ejb-name [{1}] does not match class name[{2}] for corresponding component-defining annotation.
enterprise.deployment.annotation.handlers.ejbclsmismatch=Il valore <ejb-class> [{0}] in ejb-jar.xml per il nome EJB [{1}] non corrisponde al nome della classe [{2}] per l''annotazione di definizione dei componenti corrispondente.
#EN enterprise.deployment.annotation.handlers.invalidremotehome=Encountered invalid @RemoteHome interface {0}.
enterprise.deployment.annotation.handlers.invalidremotehome=Rilevata interfaccia @RemoteHome non valida {0}.
#EN enterprise.deployment.annotation.handlers.invalidlocalhome=Encountered invalid @LocalHome interface {0}.
enterprise.deployment.annotation.handlers.invalidlocalhome=Rilevata interfaccia @LocalHome non valida {0}.
#EN enterprise.deployment.annotation.handlers.nonametypelevel=TYPE-Level annotation  must specify name member.
enterprise.deployment.annotation.handlers.nonametypelevel=L'annotazione TYPE-Level deve specificare il membro del nome.
#EN enterprise.deployment.annotation.handlers.invalidinjectionmethod=Injection on a method requires a JavaBeans setter method type with one parameter
enterprise.deployment.annotation.handlers.invalidinjectionmethod=L'inserimento su un metodo richiede un tipo di metodo setter JavaBean con un parametro
#EN enterprise.deployment.annotation.handlers.injectionmethodmustreturnvoid=Injection on a method requires a void return type
enterprise.deployment.annotation.handlers.injectionmethodmustreturnvoid=L'inserimento su un metodo richiede un tipo restituito void
#EN enterprise.deployment.annotation.handlers.classnotannotated=Class must be annotated with a {1} annotation\n symbol : {1}\n location: {0}
enterprise.deployment.annotation.handlers.classnotannotated=La classe deve essere annotata con un {1} simbolo\n di annotazione: {1}\n posizione: {0}
#EN enterprise.deployment.annotation.handlers.invalidannotationforthisclass=illegal annotation for this class will be ignored
enterprise.deployment.annotation.handlers.invalidannotationforthisclass=un'annotazione non valida per questa classe verr\u00E0 ignorata
#EN enterprise.deployment.annotation.handlers.invalidinjectionmethodname=Injection method name must start with \"set\"
enterprise.deployment.annotation.handlers.invalidinjectionmethodname=Il nome del metodo di inserimento deve iniziare con \"set\"
#EN enterprise.deployment.annotation.handlers.injectionmethodnotstatic=Injection methods for application clients must be declared STATIC
enterprise.deployment.annotation.handlers.injectionmethodnotstatic=I metodi di inserimento per i client applicazione devono essere dichiarati STATIC
#EN enterprise.deployment.annotation.handlers.injectionfieldnotstatic=Injection fields for application clients must be declared STATIC
enterprise.deployment.annotation.handlers.injectionfieldnotstatic=I campi di inserimento per i client applicazione devono essere dichiarati STATIC
#EN enterprise.deployment.annotation.handlers.typeinhernotsupp=The annotation symbol inheritance is not supported.
enterprise.deployment.annotation.handlers.typeinhernotsupp=Ereditariet\u00E0 del simbolo di annotazione non supportata.
#EN enterprise.deployment.annotation.handlers.notcompsuperclass=The annotation symbol defined in super-class is not compatible with {0} ejb {1}.
enterprise.deployment.annotation.handlers.notcompsuperclass=Il simbolo di annotazione definito nella classe superiore non \u00E8 compatibile con {0} EJB {1}.
#EN enterprise.deployment.annotation.handlers.morethanoneauthannotation=One cannot have more than one of @RolesAllowed, @PermitAll, @DenyAll in the same AnnotatedElement.
enterprise.deployment.annotation.handlers.morethanoneauthannotation=Impossibile detenere pi\u00F9 di uno tra i seguenti elementi: @RolesAllowed, @PermitAll, @DenyAll nello stesso AnnotatedElement.
#EN enterprise.deployment.annotation.handlers.warningdenyalltransportprotected=One should not have @DenyAll and @TransportProtected together. The @TransportProtected would be ignored.
enterprise.deployment.annotation.handlers.warningdenyalltransportprotected=Impossibile utilizzare @DenyAll e @TransportProtected insieme. @TransportProtected verrebbe ignorato.
#EN enterprise.deployment.annotation.handlers.notmatchcreate=Unable to find matching Home create method for Init method {0} on bean {1}.
enterprise.deployment.annotation.handlers.notmatchcreate=Impossibile trovare metodo di creazione Home corrispondente per il metodo di inizializzazione {0} sul bean {1}.
#EN enterprise.deployment.annotation.handlers.typenotfound=TYPE-level annotation symbol must specify type member.
enterprise.deployment.annotation.handlers.typenotfound=Il simbolo di annotazione TYPE-level deve specificare il membro del tipo.
#EN enterprise.deployment.annotation.handlers.invalidtype=annotation not allowed on this element.  
enterprise.deployment.annotation.handlers.invalidtype=annotazione non consentita su questo elemento.  
#EN enterprise.deployment.annotation.handlers.classnotfound=class {0} referenced from annotation symbol cannot be loaded
enterprise.deployment.annotation.handlers.classnotfound=impossibile caricare la classe {0} a cui fa riferimento il simbolo di annotazione
#EN enterprise.deployment.annotation.handlers.componentnotfound=component referenced from annotation symbol cannot be found
enterprise.deployment.annotation.handlers.componentnotfound=impossibile trovare il componente a cui fa riferimento il simbolo di annotazione
#EN enterprise.deployment.annotation.handlers.handlerfilenotfound=handler file {0} not found
enterprise.deployment.annotation.handlers.handlerfilenotfound=file handler {0} non trovato
#EN enterprise.deployment.annotation.handlers.parserexception={0} XML Parsing error : line  {1} ; Error = {2}
enterprise.deployment.annotation.handlers.parserexception={0} Errore di analisi XML: riga {1}; errore = {2}
#EN enterprise.deployment.annotation.handlers.wrongannotationlocation=symbol annotation can only be specified on TYPE
enterprise.deployment.annotation.handlers.wrongannotationlocation=\u00E8 possibile specificare il simbolo di annotazione solo su TYPE
#EN enterprise.deployment.annotation.handlers.handlerfilehandlernotfound=handler class {0} specified in handler file {1} cannot be loaded
enterprise.deployment.annotation.handlers.handlerfilehandlernotfound=impossibile caricare la classe handler {0} specificata nel file handler {1}
#EN enterprise.deployment.annotation.handlers.ddhandlernotfound=handler class {0} specified in deployment descriptors
enterprise.deployment.annotation.handlers.ddhandlernotfound=classe handler {0} specificata nei descrittori di distribuzione
#EN enterprise.deployment.annotation.handlers.handlerchainnotfound=Unable to get @HandlerChainin {0}
enterprise.deployment.annotation.handlers.handlerchainnotfound=Impossibile ottenere @HandlerChainin {0}
#EN enterprise.deployment.annotation.handlers.webeppkgwrong=Class {0} is annotated with @WebService and without @Stateless but is packaged in a JAR. If it is supposed to be a servlet endpoint, it should be packaged in a WAR; Deployment will continue assuming this class to be just a POJO used by other classes in the JAR being deployed
enterprise.deployment.annotation.handlers.webeppkgwrong=La classe {0} \u00E8 annotata con @WebService e senza @Stateless ma \u00E8 inclusa in un package in un JAR. Se \u00E8 intesa come endpoint di un servlet, deve essere inclusa in un package WAR. La distribuzione continuer\u00E0 supponendo che questa classe sia semplicemente un POJO utilizzato dalle altre classi nel JAR in fase di distribuzione.
#EN enterprise.deployment.annotation.handlers.ejbeppkgwrong=Class {0} is annotated with @WebService and @Stateless but is packaged in a WAR. If it is supposed to be an EJB endpoint, it should be packaged in a JAR; Deployment will continue assuming this class to be just a POJO used by other classes in the WAR being deployed
enterprise.deployment.annotation.handlers.ejbeppkgwrong=La classe {0} \u00E8 annotata con @WebService e @Stateless ma \u00E8 inclusa in un package in un WAR. Se \u00E8 intesa come endpoint EJB, deve essere inclusa in un package ini un JAR. La distribuzione continuer\u00E0 supponendo che questa classe sia semplicemente un POJO utilizzato dalle altre classi nel WAR in fase di distribuzione.
#EN enterprise.deployment.annotation.handlers.needtoextend=The Class {0} having annotation {1} need to be a derived class of {2}.
enterprise.deployment.annotation.handlers.needtoextend=La classe {0} con l''annotazione {1} deve essere una classe derivata di {2}.
#EN enterprise.deployment.annotation.handlers.needtoimpl=The Class {0} having annotation {1} need to implement the interface {2}.
enterprise.deployment.annotation.handlers.needtoimpl=La classe {0} con l''annotazione {1} deve implementare l''interfaccia {2}.
#EN enterprise.deployment.annotation.handlers.needtoimplinterfaces=The Class {0} having annotation javax.servlet.annotation.WebListener need to implement one of the following interfaces: javax.servlet.ServletContextLisener, javax.servlet.ServletContextAttributeListener, javax.servlet.ServletRequestListener, javax.servletServletRequestAttributeListener, javax.servlet.http.HttpSessionListener, javax.servlet.http.HttpSessionAttributeListener.
enterprise.deployment.annotation.handlers.needtoimplinterfaces=La classe {0} con l''annotazione javax.servlet.annotation.WebListener deve implementare una delle seguenti interfacce: javax.servlet.ServletContextLisener, javax.servlet.ServletContextAttributeListener, javax.servlet.ServletRequestListener, javax.servletServletRequestAttributeListener, javax.servlet.http.HttpSessionListener, javax.servlet.http.HttpSessionAttributeListener.
#EN enterprise.deployment.annotation.handlers.invalidUrlPatterns=Invalid url Patterns for {0}: {1}.
enterprise.deployment.annotation.handlers.invalidUrlPatterns=Pattern URL non validi per {0}: {1}.
#EN enterprise.deployment.annotation.handlers.servletimpldontmatch=The servlet ''{0}'' has implementation ''{1}'' in xml. It does not match with ''{2}'' from annotation @WebServlet.
enterprise.deployment.annotation.handlers.servletimpldontmatch=Il servlet ''{0}'' ha l''implementazione ''{1}'' in xml. Non corrisponde a ''{2}'' dell''annotazione @WebServlet.
#EN enterprise.deployment.annotation.handlers.servletimpljspdontmatch=The servlet ''{0}'' is a jsp ''{1}'' in xml. It does not match with ''{2}'' from annotation @{3}.
enterprise.deployment.annotation.handlers.servletimpljspdontmatch=Il servlet ''{0}'' \u00E8 un JSP ''{1}'' in xml. Non corrisponde a ''{2}'' dell''annotazione @{3}.
#EN enterprise.deployment.annotation.handlers.filterimpldontmatch=The filter ''{0}'' has implementation ''{1}'' in xml. It does not match with ''{2}'' from annotation @ServletFilter.
enterprise.deployment.annotation.handlers.filterimpldontmatch=Il filtro ''{0}'' ha l''implementazione ''{1}'' in xml. Non corrisponde a ''{2}'' dell''annotazione @ServletFilter.
#EN enterprise.deployment.annotation.handlers.datasourcedefinitionsduplicates=@DataSourceDefinitions cannot have multiple definitions with same name : ''{0}''
enterprise.deployment.annotation.handlers.datasourcedefinitionsduplicates=@DataSourceDefinitions non pu\u00F2 avere pi\u00F9 definizioni con lo stesso nome: ''{0}''
#EN enterprise.deployment.annotation.handlers.datasourcedefinitionsfailure=failed to handle annotation [ {0} ] on class [ {1} ] due to the following exception :
enterprise.deployment.annotation.handlers.datasourcedefinitionsfailure=impossibile gestire l''annotazione [ {0} ] sulla classe [ {1} ] a causa dell''eccezione seguente:
#EN enterprise.deployment.annotation.handlers.connectorannotationfailure=failed to handle annotation [ {0} ] on class [ {1} ], reason : {2} 
enterprise.deployment.annotation.handlers.connectorannotationfailure=impossibile gestire l''annotazione [ {0} ] sulla classe [ {1} ], motivo: {2} 
#EN enterprise.deployment.annotation.handlers.configpropertyfieldreadfailure=failed to read the value of field [{0}] on class [{1}], reason : {2}
enterprise.deployment.annotation.handlers.configpropertyfieldreadfailure=impossibile leggere il valore del campo [{0}] sulla classe [{1}], motivo: {2}
#EN enterprise.deployment.annotation.handlers.denyWithRolesAllowed=One cannot specify DENY with an non-empty array of rolesAllowed in @ServletSecurity / ServletSecurityElement
enterprise.deployment.annotation.handlers.denyWithRolesAllowed=Impossibile specificare DENY con un array non vuoto di rolesAllowed in @ServletSecurity / ServletSecurityElement
#EN enterprise.deployment.annotation.handlers.wrongresourceclass=Incorrect @Resource annotation class definition - missing lookup attribute
enterprise.deployment.annotation.handlers.wrongresourceclass=Definizione della classe di annotazione @Resource non corretta - attributo ricerca mancante
#EN enterprise.deployment.annotation.handlers.emptyEJBs=No @EJB elements in @EJBs: {0}, on {1}
enterprise.deployment.annotation.handlers.emptyEJBs=Nessun elemento @EJB negli @EJB: {0} in {1}
#EN enterprise.deployment.annotation.handlers.invalidauthenticationtype=Invalid AuthenticationType [{0}] in @Resource with name() = [{1}] and type = [{1}] in {2}.
enterprise.deployment.annotation.handlers.invalidauthenticationtype=Tipo di autenticazione [{0}] non valido in @Resource con name() = [{1}] e tipo = [{1}] in {2}.
