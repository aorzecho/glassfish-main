#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2010 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

# Resource bundle for sqlstore runtime messages
# key consists of: <subpackage>.<class>.<method>.<description>
# <subpackage> - is optional, package under runtime
# <class> - class name
# <method> - method name
# <description> - short description (use _ to represent space)
# all keys should be in lowercase
#
# Please note that many package names and classnames have changed over time.
# Unfortunately, this file was not maintained to follow above convention.
# Please ignore if the package/class name does not match actual names as today.
#
#
# The message ID for a message in persistence is derived as follows:
# JDO<2_digit_bundle_prefix><1_digit_section_number><2_digit_serial_number>
#
# The 2 digit prefix for this bundle is 76.
#
# This file is divided into the following sections:
# Under each section, messages that need not be I18Ned are separated under NOI18N. All other messages
# need to be numbered.
# 1. JDO:  PersistenceManagerFactory/PersistenceManager/ExtentCollection/LifeCycle
# 2. Model
# 3. StateManager
# 4. sql generator components: RetrieveDesc, ResultDesc plus all the files under generator subdir
# 5. SQLStoreManager
# 6. Connection/Connectionpool/Transaction/DBVendorType
# 7. EJB integration.
# 8. Generic messages.
#
# When adding a new message:
# 1. Please make sure that you add the message to the end of appropriate section.
# 2. Please add message ID to any user visible message.
# 3. The message ID for the new message = message ID for the last numbered
#    message in a section + 1.
# 4. Please do not change the message ID for existing messages. These
#    numbers are potentially mapped to more explanation about the message for
#    the end user.
#

####################################################################################################
# <All the source files under subdir impl (PersistenceManagerFactory/PersistenceManager etc.) >
# Message ID Range: JDO76000 - JDO76099
####################################################################################################
jdo.persistencemanagerfactoryimpl.getpersistencemanager.error=JDO76000: No se pueden utilizar varias combinaciones de nombre de usuario/contrase\u00f1a en la misma transacci\u00f3n:
jdo.persistencemanagerfactoryimpl.getpersistencemanager.notconfigured=JDO76001: PersistenceManagerFactory no est\u00e1 configurado.
jdo.persistencemanagerfactoryimpl.notsupported=JDO76002: No se admite la operaci\u00f3n para PersistenceManagerFactoryImpl interno.
jdo.persistencemanagerimpl.acquireexclusivelock.interrupted=JDO76003: No se pudo adquirir un bloqueo exclusivo debido a InterruptedException
jdo.persistencemanagerimpl.acquiresharelock.failed=JDO76004: No se pudo adquirir un bloqueo compartido debido a que _readWriteCount es inferior a cero
jdo.persistencemanagerimpl.acquiresharelock.interrupted=JDO76005: No se pudo adquirir un bloqueo compartido debido a InterruptedException
jdo.persistencemanagerimpl.another_pm=JDO76006: El objeto est\u00e1 asociado a otro PersistenceManager.
jdo.persistencemanagerimpl.assertactivetransaction.error=JDO76007: La transacci\u00f3n asociada a este Persistence Manager no est\u00e1 activa.
jdo.persistencemanagerimpl.assertclosed.closed=JDO76008: PersistenceManager est\u00e1 cerrado.
jdo.persistencemanagerimpl.assertpersistencecapable.error=JDO76009: La clase {0} no se ha mejorado para la Persistencia transparente. Use el empaquetador WAR o el JAR de IDE para empaquetar las clases compatibles con la persistencia antes de ejecutarlas. O bien, establezca la propiedad Ejecutor de la clase principal en Ejecutor de persistencia para que se ejecute desde IDE.
jdo.persistencemanagerimpl.close.activetransaction=JDO76010: Hay una transacci\u00f3n abierta asociada a este Persistence Manager.
jdo.persistencemanagerimpl.fetchinstance.none=JDO76012: No se encontr\u00f3 el objeto para este ObjectId.
jdo.persistencemanagerimpl.internaldeletepersistent.transient=JDO76014: No se puede eliminar el objeto no persistente.
jdo.persistencemanagerimpl.internalmakepersistent.dups=JDO76015: Ya existe una instancia con la misma clave principal en la cach\u00e9 de PersistenceManager.
jdo.persistencemanagerimpl.loadclassforoid.wrongoidclass=JDO76016: Error al recuperar la clase de objeto de OID.
jdo.persistencemanagerimpl.newscoinstance.wrongclass=JDO76017: No se puede crear la instancia SCO de la clase {0} porque no es un tipo v\u00e1lido.
jdo.persistencemanagerimpl.notprocessed=JDO76018: No se pueden vaciar instancias persistentes debido a dependencias circulares.
jdo.persistencemanagerimpl.releaseexclusivelock.failed=JDO76019: No se pudo liberar un bloqueo exclusivo porque _readWriteCount es superior a cero
jdo.persistencemanagerimpl.releasesharelock.failed=JDO76020: No se pudo liberar un bloqueo compartido porque _readWriteCount es igual a cero
jdo.persistencemanagerwrapper.invalidpm=JDO76021: PersistenceManagerWrapper est\u00e1 cerrado.
jdo.extentcollection.constructor.invalidclass=JDO76022: Clase ''{0}'' no v\u00e1lida para la colecci\u00f3n extendida.
jdo.extentcollection.constructor.nonpc=JDO76023: La clase ''{0}'' no admite persistencia.
jdo.extentcollection.constructor.subclasses=JDO76024: No se admite la opci\u00f3n true de las subclases para las colecciones extendidas.
jdo.extentcollection.illegalmodification=JDO76025: Modificaci\u00f3n no v\u00e1lida de colecci\u00f3n extendida para la clase ''{0}''.
jdo.extentcollection.methodnotsupported=JDO76026: No se admite el m\u00e9todo de colecci\u00f3n extendida {0}.
jdo.lifecycle.xactnotactive=JDO76027: Se necesita una transacci\u00f3n activa para realizar esta operaci\u00f3n.
jdo.persistencemanagerimpl.newinstance.badsm=JDO76028: StateManager no est\u00e1 configurado en su totalidad.
jdo.persistencemanagerimpl.setjtatransaction.notnulljta=JDO76029: Se intent\u00f3 reemplazar javax.transaction.Transaction no nulo: {0} por {1}.
jdo.persistencemanagerfactoryimpl.getpersistencemgr.closed=JDO76030: PersistenceManager para este javax.transaction.Transaction: {0} ya se ha cerrado o confirmado.
jdo.persistencemanagerfactoryimpl.registerpm.registered=JDO76031: Esta instancia de javax.transaction.Transaction: {0} ya se ha registrado con otro PersistenceManager: {1}.
jdo.persistencemanagerimpl.verificationfailed=JDO76032: La instancia de consistencia de versi\u00f3n no pudo realizar la verificaci\u00f3n con el almac\u00e9n de datos.
jdo.persistencemanagerfactoryimpl.getversionconsistencycache.nullstore=JDO76033: StoreManager no est\u00e1 configurado.

#
# <NOI18N: LifeCycle>
#
sqlstore.state.lifecyclestate.changestate=LifeCycleState.changeState(), old state = {0}, new state = {1}.
sqlstore.state.lifecyclestate.initial=LifeCycleState.getLifeCycleState(), initial state = {0}.

#
# <NOI18N: PersistenceManager>
#
sqlstore.persistencemgr.acquireexclusivelock.count=acquireExclusiveLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.acquireexclusivelock=acquireExclusiveock(), thread {0} going to wait.
sqlstore.persistencemgr.acquiresharedlock.rdwrcount=acquireShareLock(), thread {0} acquired shared lock with _readWriteCount ={1}.
sqlstore.persistencemgr.acquiresharedlock=acquireShareLock(), thread {0} going to wait.
sqlstore.persistencemgr.aftercompletion.process=---PersistenceManagerImpl.afterCompletion() process: {0}.
sqlstore.persistencemgr.aftercompletion=---PersistenceManagerImpl.afterCompletion() abort: {0}.
sqlstore.persistencemgr.assertactivetx.closed=--- PersistenceManagerImpl.assertActiveTransaction: Closed for  {0}.
sqlstore.persistencemgr.assertactivetx=--- PersistenceManagerImpl.assertActiveTransaction:  {0}.
sqlstore.persistencemgr.assertisopen=--- PersistenceManagerImpl.assertIsOpen: CLOSED for {0}.
sqlstore.persistencemgr.beforecompletion=---PersistenceManagerImpl.beforeCompletion().
sqlstore.persistencemgr.cacheproperties=PersistenceManagerImpl cache properties: _txCacheInitialCapacity={0}, _flushedCacheInitialCapacity={1}, _flushedCacheLoadFactor={2}, _weakCacheInitialCapacity={3}, _weakCacheLoadFactor={4}.
sqlstore.persistencemgr.deregisterinstance.verified=---PersistenceManagerImpl.deregisterInstance() -- deregistered with verify.
sqlstore.persistencemgr.deregisterinstance.verify=---PersistenceManagerImpl.deregisterInstance() with verify SM -- oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.deregisterinstance=---PersistenceManagerImpl.deregisterInstance() oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getbyobjid=---PersistenceManagerImpl.getObjectById() OID:{0}  for PersistenceManager: {1} and JTA: {2}.
sqlstore.persistencemgr.getcurrentwrapper=---PersistenceManagerImpl.getCurrentWrapper() > current: {0}.
sqlstore.persistencemgr.getobjid.notpc=---PersistenceManagerImpl.getObjectId() NOT PC: {0}  for PersistenceManager: {1}.
sqlstore.persistencemgr.getobjid.notpm=---PersistenceManagerImpl.getObjectId() NOT PM: {0} for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getobjid= :{0} ---PersistenceManagerImpl.getObjectId() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.internalcloneoid.old=---PersistenceManagerImpl.internalCloneOid(): old: {0}  new: {1} same: {2}.
sqlstore.persistencemgr.internalcloneoid=---PersistenceManagerImpl.internalCloneOid() ERROR: {0}.
sqlstore.persistencemgr.isactivetx=---PersistenceManagerImpl.isActiveTransaction() : {0}.
sqlstore.persistencemgr.isnontxread=---PersistenceManagerImpl.isNontransactionalRead() : {0}.
sqlstore.persistencemgr.isoptimistic=---PersistenceManagerImpl.isOptimisticTransaction() : {0}.
sqlstore.persistencemgr.loadingclass=Loading ... ClassName: {0}.
sqlstore.persistencemgr.loadingfile=Loading ... FileName: {0} {1} {2}.
sqlstore.persistencemgr.makepersistent.done=---PersistenceManagerImpl.makePersistent() {0}  finished for: {1}  and JTA: {2}.
sqlstore.persistencemgr.makepersistent= {0} ---PersistenceManagerImpl.makePersistent() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.newcollection=---PersistenceManagerImpl.newCollectionInstanceInternal() type: {0}.
sqlstore.persistencemgr.popcurrentwrapper=---PersistenceManagerImpl.popCurrentWrapper() > current: {0}  prev: {1}.
sqlstore.persistencemgr.pushcurrentwrapper=---PersistenceManagerImpl.pushCurrentWrapper() > current: {0}  new: {1}.
sqlstore.persistencemgr.registerinstance= {0} ---PersistenceManagerImpl.registerInstance() oid/sm: {1}/{2}  for PersistenceManager: {3}  and JTA: {4}.
sqlstore.persistencemgr.registerinstancein_txc=registerInstance in TXC :{0} / {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.registerinstancein_wkc=registerInstance in WKC.
sqlstore.persistencemgr.releaseexclusivelock=releaseExclusiveock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.releasesharedlock=releaseShareLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.replacingdeletedinstance=Replacing deleted instance with new for Object Id: {0}.
sqlstore.persistencemgr.setkeyfields=---PersistenceManagerImpl.setKeyFields() ERROR: {0}.
#
# <NOI18N: PersistenceManagerFactory>
#
sqlstore.sqlpersistencemgrfactory.getfrompool.pmt=<--SQLPersistenceManagerFactory.getFromPool() PM: {0} for JTA {1}.
sqlstore.sqlpersistencemgrfactory.getfrompool=<--SQLPersistenceManagerFactory.getFromPool().
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.found= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() FOUND javax.transaction.Transaction: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx.notfound=<->SQLPersistenceManagerFactory.getPersistenceManager() NOT FOUND JDO Transaction:.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx=<->SQLPersistenceManagerFactory.getPersistenceManager() JDO Transaction: {0}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmclosedfor= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() PM is CLOSED FOR: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmt= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() : {1} for JTA: {2}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr=:{0} -->SQLPersistenceManagerFactory.getPersistenceManager().
sqlstore.sqlpersistencemgrfactory.init=---SQLPersistenceManagerFactory.initialize().
sqlstore.sqlpersistencemgrfactory.pmCacheBucketSize=---SQLPersistenceManagerFactory pmCacheBucketSize = {0}.
sqlstore.sqlpersistencemgrfactory.pmCacheInitialCapacity=---SQLPersistenceManagerFactory pmCacheInitialCapacity = {0}.
sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt=<->SQLPersistenceManagerFactory.registerPersistenceManager() PM: {0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.releasepm.pmt=---SQLPersistenceManagerFactory.releasePersistenceManager() PM:{0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.returnToPool=<--SQLPersistenceManagerFactory.returnToPool().


###############################################################################
# <Model>
# Message ID Range: JDO76100 - JDO76199
###############################################################################
core.configuration.columnnotable=JDO76100: El descriptor de columna no inclu\u00eda un descriptor de tabla v\u00e1lido.
core.configuration.fieldnotable=JDO76101: El campo {0} no est\u00e1 asociado a ninguna tabla.
core.configuration.fieldnotmapped=JDO76102: El campo persistente {0} de la clase {1} no est\u00e1 asignado.
core.configuration.iddescnofield=JDO76103: No se ha configurado correctamente el objeto SqlIDDesc.  No hay ning\u00fan descriptor de campo disponible.
core.configuration.loadfailed.class=JDO76104: No se pudo cargar la configuraci\u00f3n de la clase {0}.
core.configuration.noneexistentpkfield=JDO76105: El campo {0} de la clase ObjectId {1} no existe en la clase PersistenceCapable {2}.
core.configuration.unsupportedconsistencylevel=JDO76106: La clase {0} tiene un nivel de consistencia no admitida. Los niveles de consistencia admitidos actualmente son "Ninguno", "comprobaci\u00f3n modificada al confirmar", "bloquear cuando se carguen" y "comprobar versi\u00f3n de instancias abiertas".
core.configuration.validationfailed=JDO76107: La asignaci\u00f3n de la clase {0} no es v\u00e1lida:\n{1}.
core.configuration.validationproblem=JDO76108: Error de validaci\u00f3n de la clase {0}: {1}
#
# <FieldDesc validation at runtime>
#
core.fielddesc.minvalue=JDO76109: Valor: {0} es inferior al m\u00ednimo permitido: {1} para el tipo de campo {2}.
core.fielddesc.maxvalue=JDO76110: Valor: {0} es superior al m\u00e1ximo permitido: {1} para el tipo de campo {2}.
core.configuration.noneexistentvcfield=JDO76111: El campo {0} se ha marcado como campo de versi\u00f3n, pero no existe en la clase PersistenceCapable {1}.
core.configuration.loadfailed.field=JDO76112: No se pudo cargar la configuraci\u00f3n del campo {0} en la clase {1}.

#
# <NOI18N: model>
#
sqlstore.model.classdesc.assocrelatedfield=associated relationship field = {0}.
sqlstore.model.classdesc.createsqldesc=creating SqlIDDesc from {0}.
sqlstore.model.classdesc.fieldinfo=field name = {0}, id= {1}.
sqlstore.model.classdesc.general={0}.{1} =>{2}
sqlstore.model.classdesc.getlocalfielddesc=<-> SqlPersistenceDesc.getLocalFieldDesc(), class ={0} added hidden field {1}  for column {2}.
sqlstore.model.classdesc.loadedclass=Successfully loaded oid class= {0}.
sqlstore.model.classdesc.persistconfiginit.exit=<-- SqlPersistenceConfig.initialize().
sqlstore.model.classdesc.persistconfiginit=--> SqlPersistenceConfig.initialize(), class = {0}.
sqlstore.model.classdesc.pkfield=PK field = {0}.
sqlstore.model.classdesc.primarytrackedfield=field {0} is the primary tracked field .
sqlstore.model.classdesc.unsetconcurrencychk=unsetting IN_CONCURRENCY_CHECK property for lf  {0}.
sqlstore.model.classdesc.unsetrefintegrityupdate=unsetting REF_INTEGRITY_UPDATES property for ff {0}.
sqlstore.model.classdesc.vcfield=Version consistency field = {0}.
sqlstore.model.fielddesc.addingfield=adding field {0} to be tracked by field {1}.
sqlstore.model.fielddesc.convertvalue.from_to=convertValue: {0} From: {1} To: {2}.
sqlstore.model.fielddesc.convertvalue.hidden=convertValue: hidden {0} ... return.
sqlstore.model.fielddesc.convertvalue=convertValue: NULL ... return.
sqlstore.model.fielddesc.fieldname={0} = {1}.
sqlstore.model.fielddesc.setupdesc=setupDesc(): fieldName {0} fieldType {1}.
sqlstore.model.configcacheimpl.size_before={0} size before cleanup: {1}.
sqlstore.model.configcacheimpl.size_after={0} size after cleanup: {1}.


###############################################################################
# <StateManager>
# Message ID Range: JDO76200 - JDO76299
###############################################################################
core.statemanager.anotherowner=JDO76200: No se puede asignar una instancia SCO que pertenezca a otro objeto.
core.statemanager.cantnewoid=JDO76201: No se pudo crear una instancia de clave principal nueva de la clase {0}.
core.statemanager.cantschedulejointable=JDO76202: No se pudo programar la entrada de la tabla de uni\u00f3n entre la clase {0} y {1} porque la descripci\u00f3n del campo de relaci\u00f3n es nula.
core.statemanager.cantsetkeyfield=JDO76203: No se pudo definir el valor para el campo de clave principal {0}.
core.statemanager.conflictingvalues=JDO76204: Se ha producido un conflicto de valores entre el campo {0} y el campo {1} asignados a la misma columna
core.statemanager.getfieldfailed=JDO76205: No se pudo obtener el campo.
core.statemanager.invalidpk=JDO76206: Campo de clave principal nulo {0} no v\u00e1lido al volver a cargar la instancia de la clase compatible con persistencia {1}. El Id. de objeto de la instancia es {2}.
core.statemanager.nopkupdate=JDO76207: No se permite la actualizaci\u00f3n de un campo de clave principal.
core.statemanager.nopm=JDO76208: El administrador de estado no contiene una referencia para Persistence Manager.
core.statemanager.notnavigable=JDO76209: Se intent\u00f3 acceder al campo {0} de la clase {1}.  No se cre\u00f3 previamente una instancia de este campo y esta clase no permite la navegaci\u00f3n din\u00e1mica.  Debe solicitar el campo al recuperar la clase o permitir la navegaci\u00f3n din\u00e1mica para que pueda recuperarse autom\u00e1ticamente al acceder a \u00e9l.
core.statemanager.objectnotfound=JDO76210: El objeto no existe en el almac\u00e9n de datos.
core.statemanager.poshiddenindex=JDO76211: El \u00edndice a un campo oculto deber\u00eda ser negativo. Sin embargo, se ha obtenido un \u00edndice de {0}.
core.statemanager.readonly=JDO76212: Se intent\u00f3 modificar el campo de s\u00f3lo lectura {0} de la clase {1}.
core.statemanager.releaselock.wrongthread=JDO76213: Este subproceso {0} no mantiene el bloqueo de StateManager.
core.statemanager.setfieldfailed=JDO76214: No se pudo definir el campo.
core.statemanager.wrongusageforoverlappingpkfkdelete=JDO76215: Intento incorrecto de eliminar una instancia de una relaci\u00f3n administrada. La relaci\u00f3n est\u00e1 definida por la columna de clave principal del otro lado. Para realizar una operaci\u00f3n de eliminaci\u00f3n en una colecci\u00f3n, es necesario actualizar la columna del otro lado y no est\u00e1 permitido actualizar la clave principal. Por lo tanto, s\u00f3lo puede realizarse la eliminaci\u00f3n de una instancia de una colecci\u00f3n de relaciones administradas definida por una clave principal mediante la eliminaci\u00f3n de la instancia de forma expl\u00edcita o en cascada.
core.statemanager.toomanyrows=JDO76215: Se devolvieron varias filas para una de las tablas asignada a la clase {0}.  Cada tabla asignada a una clase deber\u00eda tener s\u00f3lo una fila por cada instancia del objeto.
core.statemanager.copyFields.mismatch=JDO76216: Se intent\u00f3 copiar los campos de un StateManager a otro que est\u00e1 administrando instancias de diferentes tipos: {0} y {1}.

#
# <NOI18N: StateManager>
#
sqlstore.sqlstatemanager.adddependency=<-> SQLStateManager.addDependency(), this StateManager: {0}, other StateManager: {1}.
sqlstore.sqlstatemanager.addupdate=<-> SQLStateManager.addUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.applyupdates.exit=<-- SqlStateManager.applyUpdates().
sqlstore.sqlstatemanager.applyupdates=--> SqlStateManager.applyUpdates(), field = {0}.
sqlstore.sqlstatemanager.clearpersistencefields.exit=<--- SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.clearpersistencefields=--> SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.copychanges.exit=<-- SQLStateManager.copyChanges().
sqlstore.sqlstatemanager.copychanges=--> SQLStateManager.copyChanges(), state manager = {0}.
sqlstore.sqlstatemanager.deletepersistence=<-> SqlStateManager.deletePersistence(), type = {0}.
sqlstore.sqlstatemanager.getbeforeimage.exit=<-- SqlStateManager.getBeforeImage().
sqlstore.sqlstatemanager.getbeforeimage=--> SqlStateManager.getBeforeImage(), type = {0}.
sqlstore.sqlstatemanager.isbeforeimagerequired=isBeforeImageRequired is : {0}.
sqlstore.sqlstatemanager.loadforread.exit=<-- SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforread=--> SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforupdate.exit=<-- SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loadforupdate=--> SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loggingfield=logging field = {0} with value = {1}.
sqlstore.sqlstatemanager.makedirty.fixscocollection=--- SqlStateManager.makeDirty(), fix SCOCollection.
sqlstore.sqlstatemanager.makedirty.fixscodate=--- SqlStateManager.makeDirty(), fix SCODate.
sqlstore.sqlstatemanager.makedirty=--> SqlStateManager.makeDirty(), field = {0}.
sqlstore.sqlstatemanager.makedirtyfield=marked dirty field = {0}.
sqlstore.sqlstatemanager.makepersistence=<-> SqlStateManager.makePersistence(), type = {0}.
sqlstore.sqlstatemanager.makepresent=--> SqlStateManager.makePresent(), field = {0}.
sqlstore.sqlstatemanager.marking=marking: {0} as present.
sqlstore.sqlstatemanager.newtype=New Type: {0}.
sqlstore.sqlstatemanager.nosuchmethodexcep.clone=Exception : {0}  clone ... for type {1}.
sqlstore.sqlstatemanager.preparegetfield.exit=<-- SqlStateManager.prepareGetField().
sqlstore.sqlstatemanager.preparegetfield=--> SqlStateManager.prepareGetField(), name = {0}.
sqlstore.sqlstatemanager.preparesetfield.exit=<-- SQLStateManager.prepareSetField().
sqlstore.sqlstatemanager.preparesetfield=--> SQLStateManager.prepareSetField(), name = {0}.
sqlstore.sqlstatemanager.preparetoupdateph1.exit=<-- SqlStateManager.prepareToUpdateI().
sqlstore.sqlstatemanager.preparetoupdateph1=--> SqlStateManager.prepareToUpdatePhaseI(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph2.exit=<-- SqlStateManager.prepareToUpdateII().
sqlstore.sqlstatemanager.preparetoupdateph2=--> SqlStateManager.prepareToUpdatePhaseII(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph3.exit=<-- SqlStateManager.prepareToUpdateIII().
sqlstore.sqlstatemanager.preparetoupdateph3=--> SqlStateManager.prepareToUpdatePhaseIII(), type = {0}.
sqlstore.sqlstatemanager.prepareupdatefield.exit=<-- SQLStateManager.prepareUpdateField().
sqlstore.sqlstatemanager.prepareupdatefield=--> SQLStateManager.prepareUpdateField(), name = {0} for state: {1}.
sqlstore.sqlstatemanager.prepareupdatefieldspl.exit=<-- SQLStateManager.prepareUpdateFieldSpecial().
sqlstore.sqlstatemanager.prepareupdatefieldspl=--> SQLStateManager.prepareUpdateFieldSpecial, name = {0} for state: {1}.
sqlstore.sqlstatemanager.processcollectionupdate.exit=<-- SQLStateManager.processCollectionUpdates().
sqlstore.sqlstatemanager.processcollectionupdate=--> SQLStateManager.processCollectionUpdates(), beforeList={0}, afterlist={1}.
sqlstore.sqlstatemanager.processforeign=process foreign field ={0}.
sqlstore.sqlstatemanager.processforeignfield.remove=-- SQLStateManager.processForeignField(): was Collection - remove.
sqlstore.sqlstatemanager.processforeignfield.remove_from_bi=-- SQLStateManager.processForeignField(): is SCOCollection - remove from BI.
sqlstore.sqlstatemanager.processforeignfield.reset=-- SQLStateManager.processForeignField(): was SCOCollection - reset.
sqlstore.sqlstatemanager.processforeignfield=-- SQLStateManager.processForeignField(): value: {0} type: {1}.
sqlstore.sqlstatemanager.realizefield.exit=<-- SqlStateManager.realizeField().
sqlstore.sqlstatemanager.realizefield=--> SqlStateManager.realizeField(), name = {0}.
sqlstore.sqlstatemanager.realizeforeignfield.exit=<-- SqlStateManager.realizeField(), field realized = {0}.
sqlstore.sqlstatemanager.realizeforeignfield=--> SqlStateManager.realizeField(), name = {0}.
sqlstore.sqlstatemanager.recordingfield=recording field = {0}.
sqlstore.sqlstatemanager.refreshpersistent.exit=<-- SqlStateManager.refreshPersistent().
sqlstore.sqlstatemanager.refreshpersistent=--> SqlStateManager.refreshPersistence(), type = {0}.
sqlstore.sqlstatemanager.reload.exit=<-- SqlStateManager.reload(FieldDesc).
sqlstore.sqlstatemanager.reload=--> SqlStateManager.reload(FieldDesc), type = {0}, field = {1}.
sqlstore.sqlstatemanager.removeupdate=<-> SQLStateManager.removeUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.replaceobjectfield.unsetsco=-- SqlStateManager.replaceObjectField(), unset SCO.
sqlstore.sqlstatemanager.replaceobjectfield=-- SqlStateManager.replaceObjectField(), field = {0}, type= {1}.
sqlstore.sqlstatemanager.reset=--> SqlStateManager.reset(), retValues = {0}, wasNew: {1}, keepState: {2}.
sqlstore.sqlstatemanager.resettingcollection=Resetting Collection.
sqlstore.sqlstatemanager.resettingdate=Resetting Date.
sqlstore.sqlstatemanager.resolvedependencies=<-> SQLStateManager.resolveDependencies(), obj={0}.
sqlstore.sqlstatemanager.resolvedependency=<-> SQLStateManager.resolveDependency(), dependency resolved: lobj={0}, f={1}, fobj={2}.
sqlstore.sqlstatemanager.retrieve.exit=<-- SqlStateManager.retrieve().
sqlstore.sqlstatemanager.retrieve=--> SqlStateManager.retrieve(), name = {0}.
sqlstore.sqlstatemanager.retrieveforeign.exit=<-- SqlStateManager.retrieveForeign().
sqlstore.sqlstatemanager.retrieveforeign=--> SqlStateManager.retrieveForeign(), name = {0}.
sqlstore.sqlstatemanager.unsetmask=unsetting masks for field = {0}.
sqlstore.sqlstatemanager.unconditionalreload.exit=<-- SqlStateManager.reload().
sqlstore.sqlstatemanager.unconditionalreload=--> SqlStateManager.reload(), type = {0}.
sqlstore.sqlstatemanager.updatebeforeimage=<-> SQLStateManager.updateBeforeImage(), name = {0}, value = {1}.
sqlstore.sqlstatemanager.updateobjfield.exit=<-- SQLStateManager.updateObjectField().
sqlstore.sqlstatemanager.updateobjfield=--> SQLStateManager.updateObjectField(), name = {0}, type = {1}.
sqlstore.sqlstatemanager.updatepersistent.exit=<-- SqlStateManager.updatePersistent().
sqlstore.sqlstatemanager.updatepersistent.immediateflush=<--> SqlStateManager.updatePersistent(), immediate flush required: obj={0}, next={1}.
sqlstore.sqlstatemanager.updatepersistent.skipped=<--> SqlStateManager.updatePersistent() skipped, type ={0}, obj= {1}.
sqlstore.sqlstatemanager.updatepersistent=--> SqlStateManager.updatePersistent(), type = {0}.
sqlstore.sqlstatemanager.updatetrackedfields.exit=<-- updateTrackedFields().
sqlstore.sqlstatemanager.updatetrackedfields=--> updateTrackedFields(), f = {0} value = {1}  fieldToIgnore = {2}.


###############################################################################
# <sql generator components: All the source files under sql.>
# Message ID Range: JDO76300 - JDO76399
###############################################################################
core.constraint.duporderby=JDO76300: Esta restricci\u00f3n es una propiedad \"order by\" para el campo {0} que ya ha sido especificado en la restricci\u00f3n \"order by\".
core.constraint.fielddisallowed=JDO76301: Se especific\u00f3 el par\u00e1metro fieldName, pero no se permite con la operaci\u00f3n {0}.
core.constraint.fieldrequired=JDO76302: Falta el par\u00e1metro fieldName. La operaci\u00f3n {0} necesita un campo.
core.constraint.illegalParameterInfo=JDO76303: Debe llamarse a addConstraint() de OP_PARAMETER con el tipo de valor ParameterInfo.
core.constraint.illegalnode=JDO76304: Nodo de restricci\u00f3n no v\u00e1lido {0} en la pila SqlConstraint.
core.constraint.illegalop=JDO76305: El par\u00e1metro de operaci\u00f3n conten\u00eda un valor {0} no v\u00e1lido.
core.constraint.needfieldnamenode=JDO76306: Error en la pila de restricciones. Se espera la inserci\u00f3n de un nombre de campo.
core.constraint.needfieldnode=JDO76307: Error en la pila de restricciones.  Se espera la inserci\u00f3n de una descripci\u00f3n de campo.
core.constraint.needvalnode=JDO76308: Error en la pila de restricciones.  Se espera la inserci\u00f3n de un valor.
core.constraint.stackempty=JDO76309: La pila de restricciones est\u00e1 vac\u00eda. No hay suficientes valores para el n\u00famero del operador.
core.constraint.unknownfield=JDO76310: El campo {0} especificado en el descriptor de recuperaci\u00f3n no es miembro de la clase {1}.
core.constraint.valdisallowed=JDO76311: Se especific\u00f3 el par\u00e1metro del valor, pero no se permite con la operaci\u00f3n {0}.
core.constraint.valrequired=JDO76312: Falta el par\u00e1metro del valor. La operaci\u00f3n {0} necesita un valor.
sqlstore.resultdesc.errorgettingvalefromresulset=JDO76313: Error al obtener el valor de resultset en el \u00edndice {0} como resultType {1}. columnSqlType {2}. Excepci\u00f3n: {3}
sqlstore.resultdesc.foreignfieldprojection=JDO76314: La consultas de {0} no deber\u00eda tener proyecciones e un campo de relaci\u00f3n.
sqlstore.resultdesc.unknownfieldtype=JDO76317: Se ha encontrado un tipo de campo desconocido {0}.
sqlstore.retrievedesc.toomanyprojections=JDO76318: No se pueden definir varias proyecciones para RetrieveDesc.
sqlstore.retrievedesc.toomanyresulttypes=JDO76319: No se pueden definir varios tipos de resultados para RetrieveDesc.
sqlstore.selectstatement.noupdatelocksupport=JDO76320: Uno de los tipos de objetos relacionado con esta consulta tiene un nivel de consistencia "bloquear cuando se carguen". Para forzar este nivel de consistencia, es necesario que el almac\u00e9n de datos admita el bloqueo de actualizaci\u00f3n por filas. El almac\u00e9n de datos no admite el bloqueo de actualizaci\u00f3n por filas.
sqlstore.sql.generator.statement.likeescapenotsupported=JDO76321: La cl\u00e1usula LIKE ESCAPE no se admite en esta base de datos.
sqlstore.sql.generator.statement.positionthreeargsnotsupported=JDO76322: El tercer arg para la cl\u00e1usula POSITION debe ser 1.
core.configuration.classnotmapped=JDO76323: La clase {0} no se ha asignado.
core.configuration.classnotmappedtotable=JDO76324: La clase {0} no est\u00e1 asignada a la tabla {1}.
sqlstore.sql.generator.statement.unexpectedconstraint=JDO76325: Una restricci\u00f3n para la operaci\u00f3n {0} no puede ser nunca el elemento ra\u00edz de una cl\u00e1usula WHERE.

# <I18N: sql generator>
# Following messages are used within other messages. They need to be i18ned but need not be numbered.
#
sqlstore.sql.generator.statement.sqlStatement=Instrucci\u00f3n SQL
sqlstore.sql.generator.statement.withinputvalues= con valores de entrada:
sqlstore.sql.generator.statement.withnoinputvalues= sin valores de entrada.


#
# <ResultDesc NOI18N>
#
sqlstore.resultdesc.deserializing=deserializing = {0}.
sqlstore.resultdesc.marking_field=marking local field {0} as present.
sqlstore.resultdesc.marking_foreign_field=marking foreign field {0} as present.
sqlstore.resultdesc.marking_key_field=marking key field {0} as present.
sqlstore.resultdesc.returning_field=returning field {0} as projection.
#
# <Misc. SQLStore NOI18N >
#
sqlstore.sql.concurrency.concurrencychkdirty.exit=--> ConcurrencyCheckDirty.update().
sqlstore.sql.concurrency.concurrencychkdirty=--> ConcurrencyCheckDirty.update(), beforeImage = {0}.
sqlstore.sql.concurrencyoptverify.resumetx=<--> ConcurrencyOptVerify.resume(), resumed transaction = {0}.
sqlstore.sql.concurrencyoptverify.suspendtx=<--> ConcurrencyOptVerify.suspend(), suspended transaction = {0}.
sqlstore.sql.concurrencyoptverify.update.exit=<-- ConcurrencyOptVerify.update().
sqlstore.sql.concurrencyoptverify.update=--> ConcurrencyOptVerify.update(), beforeImage = {0}.
sqlstore.sql.generator.dbstatement.addbatch=addbatch ({0})
sqlstore.sql.generator.dbstatement.bindinputcolumn=bindInputColumn index: {0} value: {1} sqlType: {2}.
sqlstore.sql.generator.dbstatement.executebatch=executeBatch executing {0} command(s)
sqlstore.sql.generator.selectqueryplan.processforeignfield.exit=<-- SelectQueryPlan.processForeignFields().
sqlstore.sql.generator.selectqueryplan.processforeignfield=--> SelectQueryPlan.processForeignFields(), class = {0}.
sqlstore.sql.generator.selectqueryplan.processlocalfield.exit=<-- SelectQueryPlan.processLocalFields().
sqlstore.sql.generator.selectqueryplan.processlocalfield=--> SelectQueryPlan.processLocalFields(), class = {0}.
sqlstore.sql.generator.selectqueryplan.processstmts.exit=<-- SelectQueryPlan.processStatements().
sqlstore.sql.generator.selectqueryplan.processstmts=--> SelectQueryPlan.processStatements(), class = {0}, statements = {1}.
sqlstore.sql.updateobjdescimpl.afterimagenull=AfterImage is not set.
sqlstore.sql.updateobjdescimpl.beforeimagenull=BeforeImage is not set.
sqlstore.sql.updateobjdescimpl.markrelationshipchange=<--> UpdateDesc.markRelationshipChange().
sqlstore.sql.updateobjdescimpl.updated={0} is updated.


###############################################################################
# <SQLStoreManager>
# Message ID Range: JDO76400 - JDO76499
###############################################################################
#
# <SQLStoreManager>
#
core.persistencestore.jdbcerror=JDO76400: Se obtuvo una excepci\u00f3n SQLException de JDBC al ejecutar la instrucci\u00f3n SQL:\n{0}.\nExamine la excepci\u00f3n SQLException para obtener m\u00e1s informaci\u00f3n.
sqlstore.retrievedesc.stmntsnotjoined=JDO76401: Varias instrucciones SQL no admitidas para un RetrieveDesc.
core.persistencestore.toofewrows=JDO76402: Se devolvieron menos filas de la base de datos que las que permite la cardinalidad de esta asociaci\u00f3n al intentar obtener el valor de la asociaci\u00f3n {1} de la clase {0}.  El n\u00famero m\u00ednimo de filas permitido es {2}.
core.persistencestore.toomanyobjforcard1=JDO76403: La base de datos no es consistente con el modelo persistente.  Se intent\u00f3 recuperar el objeto correspondiente a la asociaci\u00f3n {1} de los elementos recuperados {2} de la clase {0}, pero s\u00f3lo puede acomodarse un elemento ya que el l\u00edmite superior de cardinalidad es 1..
core.persistencestore.toomanyrows=JDO76405: Se devolvieron m\u00e1s filas de la base de datos que las que permite la cardinalidad de esta asociaci\u00f3n al intentar obtener el valor de la asociaci\u00f3n {1} de la clase {0}.  El n\u00famero m\u00e1ximo de filas permitido es {2}.
core.store.concurrentaccess=JDO76406: Excepci\u00f3n de acceso simult\u00e1neo: el objeto para {0} ha sido actualizado o eliminado por otra transacci\u00f3n.
sqlstore.sqlstoremanager.errorcloseresultset=JDO76407: Error al cerrar el conjunto de resultados SQL. Excepci\u00f3n: {0}
sqlstore.sqlstoremanager.errorclosestatement=JDO76408: Error al cerrar la instrucci\u00f3n SQL. Excepci\u00f3n: {0}
sqlstore.sql.generator.selectqueryplan.plansnotjoined=JDO76409: Varios planes de consulta no admitidos para un RetrieveDesc.

#
# <NOI18N: SQLStoreManager>
#
sqlstore.sqlstoremanager.executeQuery.exit=<-- SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeQuery=--> SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeupdate.exit=<-- SQLStoreManager.executeUpdate(), rows affected = {0}.
sqlstore.sqlstoremanager.executeupdate=--> SQLStoreManager.executeUpdate().
sqlstore.sqlstoremanager.executeupdatebatch.addbatch={0}; add batch.
sqlstore.sqlstoremanager.executeupdatebatch.exit=<-- SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.executeupdatebatch.exit.flush=<-- SQLStoreManager.executeUpdateBatch(), rows affected = {0}.
sqlstore.sqlstoremanager.executeupdatebatch.flushbatch={0}; flush batch.
sqlstore.sqlstoremanager.executeupdatebatch=--> SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.getpersistenceconfig=<--> SQLStoreManager.getPersistenceConfig(), classType = {0}.
sqlstore.sqlstoremanager.selectnoncorrelated.exit=<-- SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.selectnoncorrelated=--> SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.vendortype=<--> SQLStoreManager: vendor type = {0}.


###############################################################################
# <Connection/Connectionpool/DBVendorType/TransactionImpl/OracleSpecialDBOperation>
# Message ID Range: JDO76500 - JDO76599
###############################################################################
#
# <Connection/Connection Pool> - database
#
connection.connectionmanager.badnew=JDO76500: ''{0}'' nuevo debe ser superior o igual a ''{1}'' actual.
connection.connectionmanager.badvalue=JDO76501: Valor no v\u00e1lido para ''{0}''.
connection.connectionmanager.conntimeout=JDO76502: Se ha agotado el tiempo de espera de la conexi\u00f3n.
connection.connectionmanager.getconnection.mismatch=JDO76503: La conexi\u00f3n agrupada no tiene el mismo contexto de usuario.
connection.connectionmanager.isdown=JDO76504: Se est\u00e1 cerrando el administrador de conexiones.
connection.connectionmanager.maxpool=JDO76505: El conjunto de conexiones est\u00e1 al m\u00e1ximo.
connection.connectionmanager.msintervalvalue=JDO76506: MsInterval debe ser mayor que cero y menor o igual que MsWait.
connection.connectionmanager.mswaitvalue=JDO76507: MsWait debe ser superior o igual a cero.
connection.connectionmanager.nulldriver=JDO76508: Valor NULL para el nombre del controlador.
connection.connectionmanager.nullurl=JDO76509: Valor NULL para URL.
connection.connectionmanager.poolsize=JDO76510: 'maxPool' debe ser superior o igual que 'minPool'.
connection.connectionmanager.threaditerupted=JDO76511: Subproceso interrumpido.
connection.connectionmanager.zero=JDO76512: ''{0}'' debe ser superior o igual a cero.
#
# <DBVendorType>
#
sqlstore.database.dbvendor.cantloadDefaultProperties=JDO76513: No se pueden cargar las propiedades de la base de datos predeterminada.
sqlstore.database.dbvendor.init.default=JDO76514: -->No se puede cargar la propiedad de tipo de proveedor {0}. Se utilizar\u00e1 los valores predeterminados.
sqlstore.database.dbvendor.cantinstantiateclass=JDO76515: No se pudo crear la instancia de la clase {0}.
#
# <OracleSpecialDBOperation>
#
sqlstore.database.oracle.defineCol=JDO76516: No se pudo definir la columna para la instrucci\u00f3n.
sqlstore.database.oracle.nooracleavailable=JDO76517: Al inicializar la f\u00e1brica de recursos de Oracle ''{0}'', no se pudo obtener una instancia de oracle.jdbc.OraclePreparedStatement o oracle.jdbc.driver.OraclePreparedStatement. Se desactivar\u00e1 la optimizaci\u00f3n espec\u00edfica de Oracle. Si las instancias que utilizan este recurso requieren valores de enlace para las columnas asignadas a la columna de caracteres fijos, los valores se completar\u00e1n con espacios en funci\u00f3n de la longitud especificada en el archivo dbschema correspondiente.
sqlstore.database.oracle.fixedcharpadded=JDO76518: El valor "{0}" est\u00e1 vinculado a una columna CHAR. En Oracle, esto debe tratarse de forma especial. Puesto que la clase OraclePreparedStatement no pudo obtenerse del controlador, el valor se completar\u00e1 con espacios en funci\u00f3n de la longitud {1}, tal y como se especifica en el archivo dbschema capturado.
#
# <Misc.>
#
core.configuration.getvendortypefailed=JDO76519: No se pudo identificar el tipo de proveedor para el almac\u00e9n de datos.
jdo.sqlpersistencemanagerfactory.errorgettingDatabaseInfo=JDO76520: Errores al obtener la informaci\u00f3n sobre la base de datos. Se obtuvo la siguiente excepci\u00f3n:

#
# <NOI18N: Connection>
#
sqlstore.connection.conncectiomgr.found=<--> ConnectionManager.getConnection: found {0}.
sqlstore.connection.conncectiomgr.getnewconn=<--> ConnectionManager.getConnection: new {0}.
sqlstore.connection.conncectiomgr.replacefreeconn=<--> ConnectionManager.replaceFreeConnection: free {0}.
sqlstore.connectionimpl.clearxact.close=--- ConnectionImpl.clearXact: connection closed .
sqlstore.connectionimpl.clearxact.disassocxact=--- ConnectionImpl.clearXact: disassociateXact .
sqlstore.connectionimpl.clearxact=--- ConnectionImpl.clearXact: .
sqlstore.connectionimpl.close.connrelease=<--- ConnectionImpl.close: connection released.
sqlstore.connectionimpl.close.exit=<--- ConnectionImpl.close: connection closed.
sqlstore.connectionimpl.close.freepending=<--- ConnectionImpl.close: set FreePending.
sqlstore.connectionimpl.close.putfreelist=<--- ConnectionImpl.close: put in freeList.
sqlstore.connectionimpl.close.replaced=<--- ConnectionImpl.close: connection replaced.
sqlstore.connectionimpl.close=---> ConnectionImpl.close.
sqlstore.connectionimpl.close_arg=---> ConnectionImpl.close: {0}.
sqlstore.connectionimpl.commit=--- ConnectionImpl.commit: connection closed.
sqlstore.connectionimpl.finalize=--- ConnectionImpl.finalize: connection closed.
sqlstore.connectionimpl.internalcommit=--- ConnectionImpl.internalCommit: .
sqlstore.connectionimpl.pendingdisassocxact=--- ConnectionImpl.clearXact: Pending disassociateXact.
sqlstore.connectionimpl.rollback.close=--- ConnectionImpl.rollback: connection closed.
sqlstore.connectionimpl.rollback=--- ConnectionImpl.rollback:.
#
# <NOI18N: DBVendorType>
#
sqlstore.database.dbvendor.castRequiredForNumericValues=<-> DBVendorType.isCastRequiredForNumericValues(): {0}.
sqlstore.database.dbvendor.getModFunctionName=<-> DBVendorType.getModFunctionName(): {0}.
sqlstore.database.dbvendor.getNullComparisonFunctionName=<-> DBVendorType.getNullComparisonFunctionName(): {0}.
sqlstore.database.dbvendor.getConcatCast=<-> DBVendorType.getConcatCast(): {0}.
sqlstore.database.dbvendor.getSpecialDBOperation=<-> DBVendorType.getSpecialDBOperation(): {0}.
sqlstore.database.dbvendor.getabs=<-> DBVendorType.getAbs(): {0}.
sqlstore.database.dbvendor.getcharlength=<-> DBVendorType.getCharLength(): {0}.
sqlstore.database.dbvendor.getforupdate=<-> DBVendorType.getForUpdate(): {0}.
sqlstore.database.dbvendor.getholdlock=<-> DBVendorType.getHoldlock(): {0}.
sqlstore.database.dbvendor.getisnotnull=<-> DBVendorType.getIsNotNull(): {0}.
sqlstore.database.dbvendor.getisnull=<-> DBVendorType.getIsNull(): {0}.
sqlstore.database.dbvendor.getleftjoin=<-> DBVendorType.getLeftJoin(): {0}.
sqlstore.database.dbvendor.getleftjoinpost=<-> DBVendorType.getLeftJoinPost(): {0}.
sqlstore.database.dbvendor.getleftlikeescape=<-> DBVendorType.getLeftLikeEscape(): {0}.
sqlstore.database.dbvendor.getnotequal=<-> DBVendorType.getNotEqual(): {0}.
sqlstore.database.dbvendor.getposition3args=<-> DBVendorType.getPositionThreeArrgs(): {0}.
sqlstore.database.dbvendor.getposition=<-> DBVendorType.getPosition(): {0}.
sqlstore.database.dbvendor.getpositionin=<-> DBVendorType.getPositionIn(): {0}.
sqlstore.database.dbvendor.getpositionsrchsrc=<-> DBVendorType.getPositionSearchSource(): {0}.
sqlstore.database.dbvendor.getquotecharstart=<-> DBVendorType.getQuoteCharStart(): {0}.
sqlstore.database.dbvendor.getrightjoinipre=<-> DBVendorType.getRightJoin(): {0}.
sqlstore.database.dbvendor.getrightlikeescape=<-> DBVendorType.getRightLikeEscape(): {0}.
sqlstore.database.dbvendor.getrtrim=<-> DBVendorType.getRtrim(): {0}.
sqlstore.database.dbvendor.getrtrimpost=<-> DBVendorType.getRtrimPost(): {0}.
sqlstore.database.dbvendor.getsqrt=<-> DBVendorType.getSqrt(): {0}.
sqlstore.database.dbvendor.getstringconcat=<-> DBVendorType.getStringConcat(): {0}.
sqlstore.database.dbvendor.getsubstring=<-> DBVendorType.getSubstring(): {0}.
sqlstore.database.dbvendor.getsubstringfor=<-> DBVendorType.getSubstringFor(): {0}.
sqlstore.database.dbvendor.getsubstringfrom=<-> DBVendorType.getSubstringFrom(): {0}.
sqlstore.database.dbvendor.gettablelistend=<-> DBVendorType.getTableListEnd(): {0}.
sqlstore.database.dbvendor.gettableliststart=<-> DBVendorType.getTableListStart(): {0}.
sqlstore.database.dbvendor.isAnsiTrim=<-> DBVendorType.isAnsiTrim(): {0}.
sqlstore.database.dbvendor.isInlineNumeric=<-> DBVendorType.isInlineNumeric(): {0}.
sqlstore.database.dbvendor.isNativeOuterJoin=<-> DBVendorType.isNativeOuterJoin(): {0}.
sqlstore.database.dbvendor.isParameterCast=<-> DBVendorType.isParameterCast(): {0}.
sqlstore.database.dbvendor.isdistinctupdatelocksupported=<-> DBVendorType.isDistinctSupportedWithUpdateLock(): {0}.
sqlstore.database.dbvendor.islockcolumnlistsupported=<-> DBVendorType.isLockColumnListSupported(): {0}.
sqlstore.database.dbvendor.isupdatelocksupported=<-> DBVendorType.isUpdateLockSupported(): {0}.
sqlstore.database.dbvendor.mapemptystrtonull=<-> DBVendorType.mapEmptyStringToNull(): {0}.
sqlstore.database.dbvendor.overrideproperties.with=<-> DBVendorType.overrideProperties() : {0} with: {1}.
sqlstore.database.dbvendor.overrideproperties=<-> DBVendorType.overrideProperties() - NONE.
sqlstore.database.dbvendor.supportslikeescape=<-> DBVendorType.supportsLikeEscape(): {0}.
sqlstore.database.dbvendor.vendorname=<-> DBVendorType(), vendorName: [{0}]  vendorType: {1}.
#
# <NOI18N: TransactionImpl>
#
sqlstore.transactionimpl.call.info={0} Tran[ {1} ].{2}: {3} for  {4}.
sqlstore.transactionimpl.call={0} Tran[ {1} ].{2}:status = {3}, txType: {4} for  {5}.
sqlstore.transactionimpl.closeconnection=--- TransactionImpl.closeConnection() {0} for {1}.
sqlstore.transactionimpl.general={0}.
sqlstore.transactionimpl.getconnection=--- TransactionImpl.getConnection(): {0} TX optimistic: {1} referenceCount = {2} for {3}.
sqlstore.transactionimpl.releaseconnection=--- TransactionImpl.releaseConnection(): TX optimistic: {0} Inside Commit: {1} referenceCount: {2} for {3}.
sqlstore.transactionimpl.rollbackconnection=--- TransactionImpl.rollbackConnection(): {0} for {1}.
sqlstore.transactionimpl.status={0} Tran[ {1} ].setStatus: {2} => {3} for {4}.


###############################################################################
# All the source files under subdir ejb.
# Message ID Range: JDO76600 - JDO76699
###############################################################################
#
#EJBHelper messages
#
# {0} - method name
ejb.ejbhelper.nonmanaged=JDO76600: No se deber\u00eda llamar al m\u00e9todo {0} en un entorno no administrado.

#
# Common messages between SunContainerHelper and DeploymentHelper
# so they have a neutral key, that still starts with "ejb".
#
# {0} - jndi name.
ejb.jndi.lookupfailed=JDO76604: No se pudo realizar la b\u00fasqueda JNDI para cmp-resource ''{0}''.
JDO76604.diag.cause.1=El recurso CMP con este nombre JNDI no se ha registrado con esta instancia.
JDO76604.diag.cause.1=El recurso CMP con este nombre JNDI no est\u00e1 bien escrito.
JDO76604.diag.check.1=Compruebe el nombre JNDI del recurso que planea utilizar.
JDO76604.diag.check.2=Compruebe el nombre JNDI del recurso CMP especificado en el m\u00f3dulo.

# {0} - jndi name.
# {1} - returned class name.
ejb.jndi.unexpectedinstance=JDO76605: La b\u00fasqueda JNDI para cmp-resource ''{0}'' devolvi\u00f3 una instancia con un tipo inesperado: {1}.
JDO76605.diag.cause.1=El recurso CMP con este nombre JNDI no hace referencia a jdbc-resource o persistence-manager-factory-resource.
JDO76604.diag.cause.1=El recurso CMP con este nombre JNDI no est\u00e1 bien escrito.
JDO76604.diag.check.1=Compruebe el nombre JNDI del recurso que planea utilizar.
JDO76604.diag.check.2=Compruebe el nombre JNDI del recurso CMP especificado en el m\u00f3dulo.

#
# DeploymentHelper messages - ejb
#
#
#<NOI18N: DeploymentHelper>
#
ejb.DeploymentHelper.getconnection=Getting connection for JNDI name ''{0}''.

# The messages JDO76606 through JDO76615 that were originally here 
# have been moved to 
# cmp/support/ejb/src/com/sun/jdo/spi/persistence/support/ejb/ejbc/Bundle.properties
# As part of INF#
# So do not use these messages. 


#
#CMPHelper messages
#
ejb.cmphelper.nonmanaged=JDO76613: Acceso no v\u00e1lido de CMPHelper. Esta clase se utiliza s\u00f3lo para la compatibilidad con CMP y no deber\u00eda llamarse fuera de un servidor de aplicaciones.

#
#SunTransactionHelper messages
#

# {0} class name
ejb.SunTransactionHelper.wrongdatasourcetype=JDO76616: La fuente de datos no tiene el tipo esperado. Se esperaba: com.sun.appserv.jdbc.DataSource, se obtuvo: {0}.


###############################################################################
# <Generic messages. Add new messages to this section only if none of the above categories can be used.>
###############################################################################
#
# <NOI18N: generic>
#
vendor=Sun Microsystems
# majorVersion (minorVersion) buildDate
fullVersion={0} ({1}) {2}
#
# <NOI18N: This messages are used for JDOFatalInternalException from multiple places. No need to I18N>
#
core.generic.unknownfield=The field {0} is not a member of the class {1}.
core.generic.unknownexception=Got an unknown exception.
core.generic.nullparam=The {0} parameter is null.
core.generic.notinstanceof=The object of class {0} is not an instance of {1}.


###############################################################################
# <These messages are used from multiple places in code.It is absolutely necessary to cleanup code
# to use different messages >
###############################################################################
core.configuration.cantloadclass=No se pudo cargar la clase {0}.
sqlstore.exception.log=Excepci\u00f3n.
jdo.lifecycle.deleted.accessField=No se puede acceder a un campo de una instancia eliminada.
