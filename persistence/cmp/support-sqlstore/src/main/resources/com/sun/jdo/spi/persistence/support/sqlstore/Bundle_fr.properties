#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2010 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

# Resource bundle for sqlstore runtime messages
# key consists of: <subpackage>.<class>.<method>.<description>
# <subpackage> - is optional, package under runtime
# <class> - class name
# <method> - method name
# <description> - short description (use _ to represent space)
# all keys should be in lowercase
#
# Please note that many package names and classnames have changed over time.
# Unfortunately, this file was not maintained to follow above convention.
# Please ignore if the package/class name does not match actual names as today.
#
#
# The message ID for a message in persistence is derived as follows:
# JDO<2_digit_bundle_prefix><1_digit_section_number><2_digit_serial_number>
#
# The 2 digit prefix for this bundle is 76.
#
# This file is divided into the following sections:
# Under each section, messages that need not be I18Ned are separated under NOI18N. All other messages
# need to be numbered.
# 1. JDO:  PersistenceManagerFactory/PersistenceManager/ExtentCollection/LifeCycle
# 2. Model
# 3. StateManager
# 4. sql generator components: RetrieveDesc, ResultDesc plus all the files under generator subdir
# 5. SQLStoreManager
# 6. Connection/Connectionpool/Transaction/DBVendorType
# 7. EJB integration.
# 8. Generic messages.
#
# When adding a new message:
# 1. Please make sure that you add the message to the end of appropriate section.
# 2. Please add message ID to any user visible message.
# 3. The message ID for the new message = message ID for the last numbered
#    message in a section + 1.
# 4. Please do not change the message ID for existing messages. These
#    numbers are potentially mapped to more explanation about the message for
#    the end user.
#

####################################################################################################
# <All the source files under subdir impl (PersistenceManagerFactory/PersistenceManager etc.) >
# Message ID Range: JDO76000 - JDO76099
####################################################################################################
jdo.persistencemanagerfactoryimpl.getpersistencemanager.error=JDO76000 : Impossible d\u2019utiliser des combinaisons multiples nom d\u2019utilisateur/mot de passe dans la m\u00eame transaction.
jdo.persistencemanagerfactoryimpl.getpersistencemanager.notconfigured=JDO76001 : PersistenceManagerFactory n\u2019est pas configur\u00e9.
jdo.persistencemanagerfactoryimpl.notsupported=JDO76002 : L\u2019op\u00e9ration n\u2019est pas prise en charge pour le PersistenceManagerFactoryImpl interne.
jdo.persistencemanagerimpl.acquireexclusivelock.interrupted=JDO76003 : \u00c9chec de l\u2019obtention d\u2019un verrou exclusif en raison de InterruptedException.
jdo.persistencemanagerimpl.acquiresharelock.failed=JDO76004 : \u00c9chec de l\u2019obtention d\u2019un verrou de partage car la valeur _readWritecount est inf\u00e9rieure \u00e0 z\u00e9ro
jdo.persistencemanagerimpl.acquiresharelock.interrupted=JDO76005 : Impossible d\u2019obtenir un verrou de partage en raison de InterruptedException.
jdo.persistencemanagerimpl.another_pm=JDO76006 : L\u2019objet est associ\u00e9 \u00e0 un autre gestionnaire de persistance.
jdo.persistencemanagerimpl.assertactivetransaction.error=JDO76007 : La transaction associ\u00e9e \u00e0 ce gestionnaire de persistance n\u2019est pas active.
jdo.persistencemanagerimpl.assertclosed.closed=JDO76008 : Le PersistenceManager est ferm\u00e9.
jdo.persistencemanagerimpl.assertpersistencecapable.error=JDO76009 : La classe {0} n\u2019a pas \u00e9t\u00e9 am\u00e9lior\u00e9e pour la persistance transparente. Utilisez l\u2019outil de paquetage JAR ou WAR de IDE pour empaqueter vos classes capables de persistance avant l\u2019ex\u00e9cution. Ou bien, \u00e9tablissez la propri\u00e9t\u00e9 de l\u2019ex\u00e9cuteur de la classe principale vers Ex\u00e9cuteur de persistance afin qu\u2019elle fonctionne depuis l\u2019IDE.
jdo.persistencemanagerimpl.close.activetransaction=JDO76010 : Il existe une transaction ouverte associ\u00e9e \u00e0 ce gestionnaire de persistance.
jdo.persistencemanagerimpl.fetchinstance.none=JDO76012 : Pas d\u2019objet trouv\u00e9 pour cet ID objet.
jdo.persistencemanagerimpl.internaldeletepersistent.transient=JDO76014 : Impossible de supprimer un objet non persistant.
jdo.persistencemanagerimpl.internalmakepersistent.dups=JDO76015 : Une instance poss\u00e9dant la m\u00eame cl\u00e9 primaire existe d\u00e9j\u00e0 dans ce cache PersistenceManager.
jdo.persistencemanagerimpl.loadclassforoid.wrongoidclass=JDO76016 : Erreur lors de la r\u00e9cup\u00e9ration de l\u2019objet Classe depuis OID.
jdo.persistencemanagerimpl.newscoinstance.wrongclass=JDO76017 : Impossible de cr\u00e9er une instance SCO de la classe {0} car elle n\u2019est pas d\u2019un type valide.
jdo.persistencemanagerimpl.notprocessed=JDO76018 : Impossible de se d\u00e9barrasser des instances persistantes en raison des d\u00e9pendances circulaires.
jdo.persistencemanagerimpl.releaseexclusivelock.failed=JDO76019 : \u00c9chec de l\u2019octroi d\u2019un verrou exclusif car la valeur _readWriteCount est sup\u00e9rieure \u00e0 z\u00e9ro.
jdo.persistencemanagerimpl.releasesharelock.failed=JDO76020 : \u00c9chec de l\u2019\u00e9mission d\u2019un verrou de partage car la valeur _readWriteCount est \u00e9gale \u00e0 z\u00e9ro.
jdo.persistencemanagerwrapper.invalidpm=JDO76021 : Le PersistenceManagerWrapper est ferm\u00e9.
jdo.extentcollection.constructor.invalidclass=JDO76022 : Classe invalide \u2019{0}\u2019 pour la collection de domaines.
jdo.extentcollection.constructor.nonpc=JDO76023 : La classe \u2019{0}\u2019 n\u2019est pas capable de persistance.
jdo.extentcollection.constructor.subclasses=JDO76024 : Les sous-classes d\u2019option vrai ne sont pas prises en charge pour les collections de domaines.
jdo.extentcollection.illegalmodification=JDO76025 : Modification non autoris\u00e9e de la collection de domaines pour la classe \u2019{0}\u2019.
jdo.extentcollection.methodnotsupported=JDO76026 : La m\u00e9thode de collection de domaines {0} n\u2019est pas prise en charge.
jdo.lifecycle.xactnotactive=JDO76027 : Une transaction active est n\u00e9cessaire pour r\u00e9aliser cette op\u00e9ration.
jdo.persistencemanagerimpl.newinstance.badsm=JDO76028 : StateManager n\u2019est pas totalement configur\u00e9.
jdo.persistencemanagerimpl.setjtatransaction.notnulljta=JDO76029 : Tentative de remplacement de la transaction non null javax.transaction.Transaction : {0} par {1}.
jdo.persistencemanagerfactoryimpl.getpersistencemgr.closed=JDO76030 : Le PersistenceManager pour la transaction javax.transaction.Transaction : {0} est d\u00e9j\u00e0 ferm\u00e9 ou en cours de validation.
jdo.persistencemanagerfactoryimpl.registerpm.registered=JDO76031 : L\u2019instance de javax.transaction.Transaction : {0} est d\u00e9j\u00e0 enregistr\u00e9e dans un autre PersistenceManager : {1}.
jdo.persistencemanagerimpl.verificationfailed=JDO76032 : L\u2019instance de coh\u00e9rence de la version n\u2019a pas pu effectuer la v\u00e9rification avec le magasin de donn\u00e9es.
jdo.persistencemanagerfactoryimpl.getversionconsistencycache.nullstore=JDO76033 : StoreManager n\u2019est pas configur\u00e9.

#
# <NOI18N: LifeCycle>
#
sqlstore.state.lifecyclestate.changestate=LifeCycleState.changeState(), old state = {0}, new state = {1}.
sqlstore.state.lifecyclestate.initial=LifeCycleState.getLifeCycleState(), initial state = {0}.

#
# <NOI18N: PersistenceManager>
#
sqlstore.persistencemgr.acquireexclusivelock.count=acquireExclusiveLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.acquireexclusivelock=acquireExclusiveock(), thread {0} going to wait.
sqlstore.persistencemgr.acquiresharedlock.rdwrcount=acquireShareLock(), thread {0} acquired shared lock with _readWriteCount ={1}.
sqlstore.persistencemgr.acquiresharedlock=acquireShareLock(), thread {0} going to wait.
sqlstore.persistencemgr.aftercompletion.process=---PersistenceManagerImpl.afterCompletion() process: {0}.
sqlstore.persistencemgr.aftercompletion=---PersistenceManagerImpl.afterCompletion() abort: {0}.
sqlstore.persistencemgr.assertactivetx.closed=--- PersistenceManagerImpl.assertActiveTransaction: Closed for  {0}.
sqlstore.persistencemgr.assertactivetx=--- PersistenceManagerImpl.assertActiveTransaction:  {0}.
sqlstore.persistencemgr.assertisopen=--- PersistenceManagerImpl.assertIsOpen: CLOSED for {0}.
sqlstore.persistencemgr.beforecompletion=---PersistenceManagerImpl.beforeCompletion().
sqlstore.persistencemgr.cacheproperties=PersistenceManagerImpl cache properties: _txCacheInitialCapacity={0}, _flushedCacheInitialCapacity={1}, _flushedCacheLoadFactor={2}, _weakCacheInitialCapacity={3}, _weakCacheLoadFactor={4}.
sqlstore.persistencemgr.deregisterinstance.verified=---PersistenceManagerImpl.deregisterInstance() -- deregistered with verify.
sqlstore.persistencemgr.deregisterinstance.verify=---PersistenceManagerImpl.deregisterInstance() with verify SM -- oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.deregisterinstance=---PersistenceManagerImpl.deregisterInstance() oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getbyobjid=---PersistenceManagerImpl.getObjectById() OID:{0}  for PersistenceManager: {1} and JTA: {2}.
sqlstore.persistencemgr.getcurrentwrapper=---PersistenceManagerImpl.getCurrentWrapper() > current: {0}.
sqlstore.persistencemgr.getobjid.notpc=---PersistenceManagerImpl.getObjectId() NOT PC: {0}  for PersistenceManager: {1}.
sqlstore.persistencemgr.getobjid.notpm=---PersistenceManagerImpl.getObjectId() NOT PM: {0} for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getobjid= :{0} ---PersistenceManagerImpl.getObjectId() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.internalcloneoid.old=---PersistenceManagerImpl.internalCloneOid(): old: {0}  new: {1} same: {2}.
sqlstore.persistencemgr.internalcloneoid=---PersistenceManagerImpl.internalCloneOid() ERROR: {0}.
sqlstore.persistencemgr.isactivetx=---PersistenceManagerImpl.isActiveTransaction() : {0}.
sqlstore.persistencemgr.isnontxread=---PersistenceManagerImpl.isNontransactionalRead() : {0}.
sqlstore.persistencemgr.isoptimistic=---PersistenceManagerImpl.isOptimisticTransaction() : {0}.
sqlstore.persistencemgr.loadingclass=Loading ... ClassName: {0}.
sqlstore.persistencemgr.loadingfile=Loading ... FileName: {0} {1} {2}.
sqlstore.persistencemgr.makepersistent.done=---PersistenceManagerImpl.makePersistent() {0}  finished for: {1}  and JTA: {2}.
sqlstore.persistencemgr.makepersistent= {0} ---PersistenceManagerImpl.makePersistent() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.newcollection=---PersistenceManagerImpl.newCollectionInstanceInternal() type: {0}.
sqlstore.persistencemgr.popcurrentwrapper=---PersistenceManagerImpl.popCurrentWrapper() > current: {0}  prev: {1}.
sqlstore.persistencemgr.pushcurrentwrapper=---PersistenceManagerImpl.pushCurrentWrapper() > current: {0}  new: {1}.
sqlstore.persistencemgr.registerinstance= {0} ---PersistenceManagerImpl.registerInstance() oid/sm: {1}/{2}  for PersistenceManager: {3}  and JTA: {4}.
sqlstore.persistencemgr.registerinstancein_txc=registerInstance in TXC :{0} / {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.registerinstancein_wkc=registerInstance in WKC.
sqlstore.persistencemgr.releaseexclusivelock=releaseExclusiveock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.releasesharedlock=releaseShareLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.replacingdeletedinstance=Replacing deleted instance with new for Object Id: {0}.
sqlstore.persistencemgr.setkeyfields=---PersistenceManagerImpl.setKeyFields() ERROR: {0}.
#
# <NOI18N: PersistenceManagerFactory>
#
sqlstore.sqlpersistencemgrfactory.getfrompool.pmt=<--SQLPersistenceManagerFactory.getFromPool() PM: {0} for JTA {1}.
sqlstore.sqlpersistencemgrfactory.getfrompool=<--SQLPersistenceManagerFactory.getFromPool().
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.found= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() FOUND javax.transaction.Transaction: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx.notfound=<->SQLPersistenceManagerFactory.getPersistenceManager() NOT FOUND JDO Transaction:.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx=<->SQLPersistenceManagerFactory.getPersistenceManager() JDO Transaction: {0}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmclosedfor= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() PM is CLOSED FOR: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmt= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() : {1} for JTA: {2}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr=:{0} -->SQLPersistenceManagerFactory.getPersistenceManager().
sqlstore.sqlpersistencemgrfactory.init=---SQLPersistenceManagerFactory.initialize().
sqlstore.sqlpersistencemgrfactory.pmCacheBucketSize=---SQLPersistenceManagerFactory pmCacheBucketSize = {0}.
sqlstore.sqlpersistencemgrfactory.pmCacheInitialCapacity=---SQLPersistenceManagerFactory pmCacheInitialCapacity = {0}.
sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt=<->SQLPersistenceManagerFactory.registerPersistenceManager() PM: {0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.releasepm.pmt=---SQLPersistenceManagerFactory.releasePersistenceManager() PM:{0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.returnToPool=<--SQLPersistenceManagerFactory.returnToPool().


###############################################################################
# <Model>
# Message ID Range: JDO76100 - JDO76199
###############################################################################
core.configuration.columnnotable=JDO76100 : Le descripteur de colonne ne poss\u00e9dait pas un descripteur de table valide.
core.configuration.fieldnotable=JDO76101 : Le champ {0} n\u2019est associ\u00e9 \u00e0 aucune table.
core.configuration.fieldnotmapped=JDO76102 : Le champ persistant {0} pour la classe {1} n\u2019est pas mapp\u00e9.
core.configuration.iddescnofield=JDO76103 : L\u2019objet SqlIDDesc n\u2019a pas \u00e9t\u00e9 d\u00e9fini correctement.  Les descripteurs de champ ne sont pas disponibles.
core.configuration.loadfailed.class=JDO76104 : \u00c9chec du chargement de la configuration pour la classe {0}.
core.configuration.noneexistentpkfield=JDO76105 : Le champ {0} dans la classe ObjectId {1} n\u2019existe pas dans la classe capable de persistance {2}.
core.configuration.unsupportedconsistencylevel=JDO76106 : Le niveau de coh\u00e9rence de la classe {0} n\u2019est pas pris en charge. Les niveaux de coh\u00e9rence pris en charge actuellement sont "none", "check-modified-at-commit", "lock-when-loaded" et "check-version-of-accessed-instances".
core.configuration.validationfailed=JDO76107 : Le mappage pour la classe {0} n\u2019est pas valide :\n{1}.
core.configuration.validationproblem=JDO76108 : Erreur de validation dans la classe {0} : {1}
#
# <FieldDesc validation at runtime>
#
core.fielddesc.minvalue=JDO76109 : Valeur : {0} est inf\u00e9rieure au minimum autoris\u00e9 : {1} pour le type de champ {2}.
core.fielddesc.maxvalue=JDO76110 : Valeur : {0} est sup\u00e9rieure au maximum autoris\u00e9 : {1} pour le type de champ {2}.
core.configuration.noneexistentvcfield=JDO76111 : Le champ {0} est d\u00e9fini comme champ de version, mais il ne figure pas dans la classe capable de persistance {1}.
core.configuration.loadfailed.field=JDO76112 : \u00c9chec du chargement de la configuration pour le champ {0} la classe {1}.

#
# <NOI18N: model>
#
sqlstore.model.classdesc.assocrelatedfield=associated relationship field = {0}.
sqlstore.model.classdesc.createsqldesc=creating SqlIDDesc from {0}.
sqlstore.model.classdesc.fieldinfo=field name = {0}, id= {1}.
sqlstore.model.classdesc.general={0}.{1} =>{2}
sqlstore.model.classdesc.getlocalfielddesc=<-> SqlPersistenceDesc.getLocalFieldDesc(), class ={0} added hidden field {1}  for column {2}.
sqlstore.model.classdesc.loadedclass=Successfully loaded oid class= {0}.
sqlstore.model.classdesc.persistconfiginit.exit=<-- SqlPersistenceConfig.initialize().
sqlstore.model.classdesc.persistconfiginit=--> SqlPersistenceConfig.initialize(), class = {0}.
sqlstore.model.classdesc.pkfield=PK field = {0}.
sqlstore.model.classdesc.primarytrackedfield=field {0} is the primary tracked field .
sqlstore.model.classdesc.unsetconcurrencychk=unsetting IN_CONCURRENCY_CHECK property for lf  {0}.
sqlstore.model.classdesc.unsetrefintegrityupdate=unsetting REF_INTEGRITY_UPDATES property for ff {0}.
sqlstore.model.classdesc.vcfield=Version consistency field = {0}.
sqlstore.model.fielddesc.addingfield=adding field {0} to be tracked by field {1}.
sqlstore.model.fielddesc.convertvalue.from_to=convertValue: {0} From: {1} To: {2}.
sqlstore.model.fielddesc.convertvalue.hidden=convertValue: hidden {0} ... return.
sqlstore.model.fielddesc.convertvalue=convertValue: NULL ... return.
sqlstore.model.fielddesc.fieldname={0} = {1}.
sqlstore.model.fielddesc.setupdesc=setupDesc(): fieldName {0} fieldType {1}.
sqlstore.model.configcacheimpl.size_before={0} size before cleanup: {1}.
sqlstore.model.configcacheimpl.size_after={0} size after cleanup: {1}.


###############################################################################
# <StateManager>
# Message ID Range: JDO76200 - JDO76299
###############################################################################
core.statemanager.anotherowner=JDO76200 : Impossible d\u2019affecter une instance SCO qui appartient \u00e0 un autre objet.
core.statemanager.cantnewoid=JDO76201 : \u00c9chec de la cr\u00e9ation d\u2019une nouvelle instance de cl\u00e9 primaire de la classe {0}.
core.statemanager.cantschedulejointable=JDO76202 : Impossible de planifier l\u2019insertion de l\u2019entr\u00e9e de la table entre la classe {0} et {1}, car la description du champ de relation est null.
core.statemanager.cantsetkeyfield=JDO76203 : \u00c9chec de la d\u00e9finition de la valeur du champ de cl\u00e9 primaire {0}.
core.statemanager.conflictingvalues=JDO76204 : Conflit de valeurs entre les champs {0} et {1} qui sont mapp\u00e9s sur la m\u00eame colonne.
core.statemanager.getfieldfailed=JDO76205 : \u00c9chec de l\u2019obtention du champ.
core.statemanager.invalidpk=JDO76206 : Champ de cl\u00e9 primaire null {0} incorrect lors du rechargement de la classe capable de persistance {1}. L\u2019ObjectId de l\u2019instance est {2}.
core.statemanager.nopkupdate=JDO76207 : La mise \u00e0 jour d\u2019un champ de cl\u00e9 primaire n\u2019est pas autoris\u00e9e.
core.statemanager.nopm=JDO76208 : Le gestionnaire d\u2019\u00e9tat ne renferme pas de r\u00e9f\u00e9rence au gestionnaire de persistance.
core.statemanager.notnavigable=JDO76209 : Une tentative d\u2019acc\u00e8s au champ {0} de la classe {1} a eu lieu.  Aucune instance de ce champ n\u2019a \u00e9t\u00e9 cr\u00e9\u00e9e auparavant et cette classe ne permet pas la navigation dynamique.  Vous devez soit adresser une requ\u00eate sur ce champ lors de l\u2019extraction de la classe ou permettre la navigation dynamique afin que ce champ puisse \u00eatre extrait automatiquement en y acc\u00e9dant.
core.statemanager.objectnotfound=JDO76210 : L\u2019objet n\u2019existe pas dans le magasin de donn\u00e9es.
core.statemanager.poshiddenindex=JDO76211 : L\u2019index vers un champ cach\u00e9 doit \u00eatre n\u00e9gatif, mais cet index est \u00e9gal \u00e0 {0}.
core.statemanager.readonly=JDO76212 : Une tentative de modification du champ en lecture seule {0} de la classe {1} a eu lieu.
core.statemanager.releaselock.wrongthread=JDO76213 : Ce thread {0} n\u2019a pas de verrou StateManager.
core.statemanager.setfieldfailed=JDO76214 : \u00c9chec de la d\u00e9finition du champ.
core.statemanager.wrongusageforoverlappingpkfkdelete=JDO76215 : Tentative de suppression incorrecte d\u2019une instance dans une relation g\u00e9r\u00e9e. La relation est d\u00e9finie par une colonne de cl\u00e9 primaire de l\u2019autre c\u00f4t\u00e9. Une op\u00e9ration de suppression dans une collection implique la mise \u00e0 jour de la colonne de l\u2019autre c\u00f4t\u00e9, et la mise \u00e0 jour des cl\u00e9s primaires n\u2019est pas autoris\u00e9e. D\u00e8s lors, la suppression d\u2019une instance dans une collection de relations g\u00e9r\u00e9es d\u00e9finie par une cl\u00e9 primaire est uniquement r\u00e9alisable en supprimant l\u2019instance, explicitement ou par suppression en cascade.
core.statemanager.toomanyrows=JDO76215 : La requ\u00eate a donn\u00e9 plus d\u2019une rang\u00e9e pour l\u2019une des tables mapp\u00e9es sur la classe {0}.  Chaque table mapp\u00e9e sur une classe devrait avoir uniquement une seule rang\u00e9e pour chaque instance de l\u2019objet.
core.statemanager.copyFields.mismatch=JDO76216 : Tentative de copie de champs d\u2019un StateManager vers un autre qui g\u00e8re des instances de plusieurs types : {0} et {1}.

#
# <NOI18N: StateManager>
#
sqlstore.sqlstatemanager.adddependency=<-> SQLStateManager.addDependency(), this StateManager: {0}, other StateManager: {1}.
sqlstore.sqlstatemanager.addupdate=<-> SQLStateManager.addUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.applyupdates.exit=<-- SqlStateManager.applyUpdates().
sqlstore.sqlstatemanager.applyupdates=--> SqlStateManager.applyUpdates(), field = {0}.
sqlstore.sqlstatemanager.clearpersistencefields.exit=<--- SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.clearpersistencefields=--> SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.copychanges.exit=<-- SQLStateManager.copyChanges().
sqlstore.sqlstatemanager.copychanges=--> SQLStateManager.copyChanges(), state manager = {0}.
sqlstore.sqlstatemanager.deletepersistence=<-> SqlStateManager.deletePersistence(), type = {0}.
sqlstore.sqlstatemanager.getbeforeimage.exit=<-- SqlStateManager.getBeforeImage().
sqlstore.sqlstatemanager.getbeforeimage=--> SqlStateManager.getBeforeImage(), type = {0}.
sqlstore.sqlstatemanager.isbeforeimagerequired=isBeforeImageRequired is : {0}.
sqlstore.sqlstatemanager.loadforread.exit=<-- SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforread=--> SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforupdate.exit=<-- SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loadforupdate=--> SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loggingfield=logging field = {0} with value = {1}.
sqlstore.sqlstatemanager.makedirty.fixscocollection=--- SqlStateManager.makeDirty(), fix SCOCollection.
sqlstore.sqlstatemanager.makedirty.fixscodate=--- SqlStateManager.makeDirty(), fix SCODate.
sqlstore.sqlstatemanager.makedirty=--> SqlStateManager.makeDirty(), field = {0}.
sqlstore.sqlstatemanager.makedirtyfield=marked dirty field = {0}.
sqlstore.sqlstatemanager.makepersistence=<-> SqlStateManager.makePersistence(), type = {0}.
sqlstore.sqlstatemanager.makepresent=--> SqlStateManager.makePresent(), field = {0}.
sqlstore.sqlstatemanager.marking=marking: {0} as present.
sqlstore.sqlstatemanager.newtype=New Type: {0}.
sqlstore.sqlstatemanager.nosuchmethodexcep.clone=Exception : {0}  clone ... for type {1}.
sqlstore.sqlstatemanager.preparegetfield.exit=<-- SqlStateManager.prepareGetField().
sqlstore.sqlstatemanager.preparegetfield=--> SqlStateManager.prepareGetField(), name = {0}.
sqlstore.sqlstatemanager.preparesetfield.exit=<-- SQLStateManager.prepareSetField().
sqlstore.sqlstatemanager.preparesetfield=--> SQLStateManager.prepareSetField(), name = {0}.
sqlstore.sqlstatemanager.preparetoupdateph1.exit=<-- SqlStateManager.prepareToUpdateI().
sqlstore.sqlstatemanager.preparetoupdateph1=--> SqlStateManager.prepareToUpdatePhaseI(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph2.exit=<-- SqlStateManager.prepareToUpdateII().
sqlstore.sqlstatemanager.preparetoupdateph2=--> SqlStateManager.prepareToUpdatePhaseII(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph3.exit=<-- SqlStateManager.prepareToUpdateIII().
sqlstore.sqlstatemanager.preparetoupdateph3=--> SqlStateManager.prepareToUpdatePhaseIII(), type = {0}.
sqlstore.sqlstatemanager.prepareupdatefield.exit=<-- SQLStateManager.prepareUpdateField().
sqlstore.sqlstatemanager.prepareupdatefield=--> SQLStateManager.prepareUpdateField(), name = {0} for state: {1}.
sqlstore.sqlstatemanager.prepareupdatefieldspl.exit=<-- SQLStateManager.prepareUpdateFieldSpecial().
sqlstore.sqlstatemanager.prepareupdatefieldspl=--> SQLStateManager.prepareUpdateFieldSpecial, name = {0} for state: {1}.
sqlstore.sqlstatemanager.processcollectionupdate.exit=<-- SQLStateManager.processCollectionUpdates().
sqlstore.sqlstatemanager.processcollectionupdate=--> SQLStateManager.processCollectionUpdates(), beforeList={0}, afterlist={1}.
sqlstore.sqlstatemanager.processforeign=process foreign field ={0}.
sqlstore.sqlstatemanager.processforeignfield.remove=-- SQLStateManager.processForeignField(): was Collection - remove.
sqlstore.sqlstatemanager.processforeignfield.remove_from_bi=-- SQLStateManager.processForeignField(): is SCOCollection - remove from BI.
sqlstore.sqlstatemanager.processforeignfield.reset=-- SQLStateManager.processForeignField(): was SCOCollection - reset.
sqlstore.sqlstatemanager.processforeignfield=-- SQLStateManager.processForeignField(): value: {0} type: {1}.
sqlstore.sqlstatemanager.realizefield.exit=<-- SqlStateManager.realizeField().
sqlstore.sqlstatemanager.realizefield=--> SqlStateManager.realizeField(), name = {0}.
sqlstore.sqlstatemanager.realizeforeignfield.exit=<-- SqlStateManager.realizeField(), field realized = {0}.
sqlstore.sqlstatemanager.realizeforeignfield=--> SqlStateManager.realizeField(), name = {0}.
sqlstore.sqlstatemanager.recordingfield=recording field = {0}.
sqlstore.sqlstatemanager.refreshpersistent.exit=<-- SqlStateManager.refreshPersistent().
sqlstore.sqlstatemanager.refreshpersistent=--> SqlStateManager.refreshPersistence(), type = {0}.
sqlstore.sqlstatemanager.reload.exit=<-- SqlStateManager.reload(FieldDesc).
sqlstore.sqlstatemanager.reload=--> SqlStateManager.reload(FieldDesc), type = {0}, field = {1}.
sqlstore.sqlstatemanager.removeupdate=<-> SQLStateManager.removeUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.replaceobjectfield.unsetsco=-- SqlStateManager.replaceObjectField(), unset SCO.
sqlstore.sqlstatemanager.replaceobjectfield=-- SqlStateManager.replaceObjectField(), field = {0}, type= {1}.
sqlstore.sqlstatemanager.reset=--> SqlStateManager.reset(), retValues = {0}, wasNew: {1}, keepState: {2}.
sqlstore.sqlstatemanager.resettingcollection=Resetting Collection.
sqlstore.sqlstatemanager.resettingdate=Resetting Date.
sqlstore.sqlstatemanager.resolvedependencies=<-> SQLStateManager.resolveDependencies(), obj={0}.
sqlstore.sqlstatemanager.resolvedependency=<-> SQLStateManager.resolveDependency(), dependency resolved: lobj={0}, f={1}, fobj={2}.
sqlstore.sqlstatemanager.retrieve.exit=<-- SqlStateManager.retrieve().
sqlstore.sqlstatemanager.retrieve=--> SqlStateManager.retrieve(), name = {0}.
sqlstore.sqlstatemanager.retrieveforeign.exit=<-- SqlStateManager.retrieveForeign().
sqlstore.sqlstatemanager.retrieveforeign=--> SqlStateManager.retrieveForeign(), name = {0}.
sqlstore.sqlstatemanager.unsetmask=unsetting masks for field = {0}.
sqlstore.sqlstatemanager.unconditionalreload.exit=<-- SqlStateManager.reload().
sqlstore.sqlstatemanager.unconditionalreload=--> SqlStateManager.reload(), type = {0}.
sqlstore.sqlstatemanager.updatebeforeimage=<-> SQLStateManager.updateBeforeImage(), name = {0}, value = {1}.
sqlstore.sqlstatemanager.updateobjfield.exit=<-- SQLStateManager.updateObjectField().
sqlstore.sqlstatemanager.updateobjfield=--> SQLStateManager.updateObjectField(), name = {0}, type = {1}.
sqlstore.sqlstatemanager.updatepersistent.exit=<-- SqlStateManager.updatePersistent().
sqlstore.sqlstatemanager.updatepersistent.immediateflush=<--> SqlStateManager.updatePersistent(), immediate flush required: obj={0}, next={1}.
sqlstore.sqlstatemanager.updatepersistent.skipped=<--> SqlStateManager.updatePersistent() skipped, type ={0}, obj= {1}.
sqlstore.sqlstatemanager.updatepersistent=--> SqlStateManager.updatePersistent(), type = {0}.
sqlstore.sqlstatemanager.updatetrackedfields.exit=<-- updateTrackedFields().
sqlstore.sqlstatemanager.updatetrackedfields=--> updateTrackedFields(), f = {0} value = {1}  fieldToIgnore = {2}.


###############################################################################
# <sql generator components: All the source files under sql.>
# Message ID Range: JDO76300 - JDO76399
###############################################################################
core.constraint.duporderby=JDO76300 : La contrainte est un \"order by\" pour le champ {0} qui a d\u00e9j\u00e0 \u00e9t\u00e9 sp\u00e9cifi\u00e9 dans une contrainte \"order by\".
core.constraint.fielddisallowed=JDO76301\u00a0: Le param\u00e8tre de nom de champ (fieldName) a \u00e9t\u00e9 d\u00e9fini mais il n\u2019est pas autoris\u00e9 avec l\u2019op\u00e9ration {0}.
core.constraint.fieldrequired=JDO76302 : Le param\u00e8tre fieldName est absent mais l\u2019op\u00e9ration {0} a besoin d\u2019un champ.
core.constraint.illegalParameterInfo=JDO76303 : addConstraint() de OP_PARAMETER doit \u00eatre appel\u00e9 avec la valeur de type ParameterInfo.
core.constraint.illegalnode=JDO76304 : N\u0153ud de contrainte {0} ill\u00e9gal dans la matrice SqlConstraint.
core.constraint.illegalop=JDO76305 : Le param\u00e8tre d\u2019op\u00e9ration contenait une valeur ill\u00e9gale pour {0}.
core.constraint.needfieldnamenode=JDO76306 : Erreur dans la matrice de contraintes. Un nom de champ est attendu.
core.constraint.needfieldnode=JDO76307 : Erreur dans la matrice de contraintes.  Une description de champ est attendue.
core.constraint.needvalnode=JDO76308 : Erreur dans la matrice de contraintes.  Une valeur est attendue.
core.constraint.stackempty=JDO76309 : La matrice de contraintes est vide. Il n\u2019y a pas assez de valeurs pour le nombre d\u2019op\u00e9rateurs.
core.constraint.unknownfield=JDO76310 : Le champ {0} d\u00e9fini dans le descripteur d\u2019extraction n\u2019appartient pas \u00e0 la classe {1}.
core.constraint.valdisallowed=JDO76311\u00a0: Le param\u00e8tre de valeur a \u00e9t\u00e9 d\u00e9fini mais il n\u2019est pas autoris\u00e9 avec l\u2019op\u00e9ration {0}.
core.constraint.valrequired=JDO76312 : Le param\u00e8tre valeur est absent mais l\u2019op\u00e9ration {0} a besoin d\u2019une valeur.
sqlstore.resultdesc.errorgettingvalefromresulset=JDO76313 : Erreur lors de l\u2019obtention de la valeur depuis resultset vers l\u2019index {0} en tant que resultType {1}. columnSqlType {2}. Exception : {3}
sqlstore.resultdesc.foreignfieldprojection=JDO76314 : Les requ\u00eates de {0} ne doivent pas avoir de projection sur un champ de relation.
sqlstore.resultdesc.unknownfieldtype=JDO76317 : Type de champ inconnu {0}.
sqlstore.retrievedesc.toomanyprojections=JDO76318 : Impossible de d\u00e9finir plusieurs projections pour RetrieveDesc.
sqlstore.retrievedesc.toomanyresulttypes=JDO76319 : Impossible de d\u00e9finir plusieurs types de r\u00e9sultat pour RetrieveDesc.
sqlstore.selectstatement.noupdatelocksupport=JDO76320 : L\u2019un des types d\u2019objet de cette requ\u00eate a le niveau de coh\u00e9rence "verrouiller-quand-charg\u00e9". L\u2019application de ce niveau de coh\u00e9rence implique que le magasin de donn\u00e9es prenne en charge le verrouillage pour les mises \u00e0 jour au niveau des rang\u00e9es. Le magasin de donn\u00e9es ne prend pas en charge le verrouillage pour les mises \u00e0 jour au niveau des rang\u00e9es.
sqlstore.sql.generator.statement.likeescapenotsupported=JDO76321 : Clause LIKE ESCAPE non prise en charge sur cette base de donn\u00e9es.
sqlstore.sql.generator.statement.positionthreeargsnotsupported=JDO76322 : Le troisi\u00e8me argument pour la clause POSITION doit \u00eatre 1.
core.configuration.classnotmapped=JDO76323 : La classe {0} n\u2019est pas mapp\u00e9e.
core.configuration.classnotmappedtotable=JDO76324 : La classe {0} n\u2019est pas mapp\u00e9e sur la table {1}.
sqlstore.sql.generator.statement.unexpectedconstraint=JDO76325 : Une contrainte d\u2019op\u00e9ration {0} ne peut jamais \u00eatre la racine d\u2019une clause where.

# <I18N: sql generator>
# Following messages are used within other messages. They need to be i18ned but need not be numbered.
#
sqlstore.sql.generator.statement.sqlStatement=Instruction SQL
sqlstore.sql.generator.statement.withinputvalues= Avec les valeurs d\u2019entr\u00e9e :
sqlstore.sql.generator.statement.withnoinputvalues= Sans valeur d\u2019entr\u00e9e.


#
# <ResultDesc NOI18N>
#
sqlstore.resultdesc.deserializing=deserializing = {0}.
sqlstore.resultdesc.marking_field=marking local field {0} as present.
sqlstore.resultdesc.marking_foreign_field=marking foreign field {0} as present.
sqlstore.resultdesc.marking_key_field=marking key field {0} as present.
sqlstore.resultdesc.returning_field=returning field {0} as projection.
#
# <Misc. SQLStore NOI18N >
#
sqlstore.sql.concurrency.concurrencychkdirty.exit=--> ConcurrencyCheckDirty.update().
sqlstore.sql.concurrency.concurrencychkdirty=--> ConcurrencyCheckDirty.update(), beforeImage = {0}.
sqlstore.sql.concurrencyoptverify.resumetx=<--> ConcurrencyOptVerify.resume(), resumed transaction = {0}.
sqlstore.sql.concurrencyoptverify.suspendtx=<--> ConcurrencyOptVerify.suspend(), suspended transaction = {0}.
sqlstore.sql.concurrencyoptverify.update.exit=<-- ConcurrencyOptVerify.update().
sqlstore.sql.concurrencyoptverify.update=--> ConcurrencyOptVerify.update(), beforeImage = {0}.
sqlstore.sql.generator.dbstatement.addbatch=addbatch ({0})
sqlstore.sql.generator.dbstatement.bindinputcolumn=bindInputColumn index: {0} value: {1} sqlType: {2}.
sqlstore.sql.generator.dbstatement.executebatch=executeBatch executing {0} command(s)
sqlstore.sql.generator.selectqueryplan.processforeignfield.exit=<-- SelectQueryPlan.processForeignFields().
sqlstore.sql.generator.selectqueryplan.processforeignfield=--> SelectQueryPlan.processForeignFields(), class = {0}.
sqlstore.sql.generator.selectqueryplan.processlocalfield.exit=<-- SelectQueryPlan.processLocalFields().
sqlstore.sql.generator.selectqueryplan.processlocalfield=--> SelectQueryPlan.processLocalFields(), class = {0}.
sqlstore.sql.generator.selectqueryplan.processstmts.exit=<-- SelectQueryPlan.processStatements().
sqlstore.sql.generator.selectqueryplan.processstmts=--> SelectQueryPlan.processStatements(), class = {0}, statements = {1}.
sqlstore.sql.updateobjdescimpl.afterimagenull=AfterImage is not set.
sqlstore.sql.updateobjdescimpl.beforeimagenull=BeforeImage is not set.
sqlstore.sql.updateobjdescimpl.markrelationshipchange=<--> UpdateDesc.markRelationshipChange().
sqlstore.sql.updateobjdescimpl.updated={0} is updated.


###############################################################################
# <SQLStoreManager>
# Message ID Range: JDO76400 - JDO76499
###############################################################################
#
# <SQLStoreManager>
#
core.persistencestore.jdbcerror=JDO76400 : SQLException JDBC lors de l\u2019ex\u00e9cution de l\u2019instruction SQL :\n{0}.\nExaminez le message de SQLException pour plus d\u2019informations.
sqlstore.retrievedesc.stmntsnotjoined=JDO76401 : Instructions SQL multiples non prises en charge pour RetrieveDesc.
core.persistencestore.toofewrows=JDO76402 : La tentative d\u2019extraction depuis la base de donn\u00e9es de la valeur pour l\u2019association {1} de la classe {0} a donn\u00e9 un nombre de rang\u00e9es inf\u00e9rieur au nombre autoris\u00e9 par la cardinalit\u00e9 de cette association.  Le nombre minimum de rang\u00e9es autoris\u00e9 est de {2}.
core.persistencestore.toomanyobjforcard1=JDO76403 : La base de donn\u00e9es n\u2019est pas coh\u00e9rente avec le mod\u00e8le persistant.  La tentative d\u2019extraction de l\u2019objet d\u00e9fini par l\u2019association de {1} de la classe {0} a fourni {2} \u00e9l\u00e9ments, mais 1 seul \u00e9l\u00e9ment peut \u00eatre trait\u00e9 car la limite sup\u00e9rieure de la cardinalit\u00e9 pour l\u2019association est de 1.
core.persistencestore.toomanyrows=JDO76405 : La tentative d\u2019extraction depuis la base de donn\u00e9es de la valeur pour l\u2019association {1} de la classe {0} a donn\u00e9 un nombre de rang\u00e9es sup\u00e9rieur au nombre autoris\u00e9 par la cardinalit\u00e9 de cette association.  Le nombre maximum de rang\u00e9es autoris\u00e9 est de {2}.
core.store.concurrentaccess=JDO76406 : Exception d\u2019acc\u00e8s simultan\u00e9 : l\u2019objet vers {0} a d\u00e9j\u00e0 \u00e9t\u00e9 mis \u00e0 jour ou supprim\u00e9 par une autre transaction.
sqlstore.sqlstoremanager.errorcloseresultset=JDO76407 : Erreur lors de la fermeture du groupe de r\u00e9sultats SQL. Exception : {0}
sqlstore.sqlstoremanager.errorclosestatement=JDO76408 : Erreur lors de la fermeture de l\u2019instruction SQL. Exception : {0}
sqlstore.sql.generator.selectqueryplan.plansnotjoined=JDO76409 : Plans de requ\u00eates multiples non pris en charge pour RetrieveDesc.

#
# <NOI18N: SQLStoreManager>
#
sqlstore.sqlstoremanager.executeQuery.exit=<-- SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeQuery=--> SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeupdate.exit=<-- SQLStoreManager.executeUpdate(), rows affected = {0}.
sqlstore.sqlstoremanager.executeupdate=--> SQLStoreManager.executeUpdate().
sqlstore.sqlstoremanager.executeupdatebatch.addbatch={0}; add batch.
sqlstore.sqlstoremanager.executeupdatebatch.exit=<-- SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.executeupdatebatch.exit.flush=<-- SQLStoreManager.executeUpdateBatch(), rows affected = {0}.
sqlstore.sqlstoremanager.executeupdatebatch.flushbatch={0}; flush batch.
sqlstore.sqlstoremanager.executeupdatebatch=--> SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.getpersistenceconfig=<--> SQLStoreManager.getPersistenceConfig(), classType = {0}.
sqlstore.sqlstoremanager.selectnoncorrelated.exit=<-- SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.selectnoncorrelated=--> SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.vendortype=<--> SQLStoreManager: vendor type = {0}.


###############################################################################
# <Connection/Connectionpool/DBVendorType/TransactionImpl/OracleSpecialDBOperation>
# Message ID Range: JDO76500 - JDO76599
###############################################################################
#
# <Connection/Connection Pool> - database
#
connection.connectionmanager.badnew=JDO76500 : Le nouveau \u2019{0}\u2019 doit \u00eatre sup\u00e9rieur ou \u00e9gal au \u2019{1}\u2019actuel.
connection.connectionmanager.badvalue=JDO76501 : La valeur pour \u2019{0}\u2019 n\u2019est pas valide.
connection.connectionmanager.conntimeout=JDO76502 : Fin du d\u00e9lai de connexion.
connection.connectionmanager.getconnection.mismatch=JDO76503 : La connexion mise en pool n\u2019a pas le m\u00eame contexte utilisateur.
connection.connectionmanager.isdown=JDO76504 : L\u2019arr\u00eat du gestionnaire de connexions est en cours.
connection.connectionmanager.maxpool=JDO76505 : Le pool de connexions est \u00e0 son maximum.
connection.connectionmanager.msintervalvalue=JDO76506 : MsInterval doit \u00eatre sup\u00e9rieur \u00e0 z\u00e9ro et inf\u00e9rieur ou \u00e9gal \u00e0 MsWait.
connection.connectionmanager.mswaitvalue=JDO76507 : MsWait doit \u00eatre sup\u00e9rieur ou \u00e9gal \u00e0 z\u00e9ro.
connection.connectionmanager.nulldriver=JDO76508 : Valeur NULL pour le nom du lecteur.
connection.connectionmanager.nullurl=JDO76509 : Valeur NULL pour l\u2019URL.
connection.connectionmanager.poolsize=JDO76510 : \u2019maxPool\u2019 doit \u00eatre sup\u00e9rieur ou \u00e9gal \u00e0 \u2019minPool\u2019.
connection.connectionmanager.threaditerupted=JDO76511 : Thread interrompu.
connection.connectionmanager.zero=JDO76512 : \u2019{0}\u2019 doit \u00eatre sup\u00e9rieur ou \u00e9gal \u00e0 z\u00e9ro.
#
# <DBVendorType>
#
sqlstore.database.dbvendor.cantloadDefaultProperties=JDO76513\u00a0: Impossible de charger les propri\u00e9t\u00e9s de la base de donn\u00e9es par d\u00e9faut.
sqlstore.database.dbvendor.init.default=JDO76514 : -->Impossible de charger la propri\u00e9t\u00e9 pour le type de fournisseur {0}. La valeur par d\u00e9faut va \u00eatre utilis\u00e9e.
sqlstore.database.dbvendor.cantinstantiateclass=JDO76515 : \u00c9chec de l\u2019instanciation de la classe {0}.
#
# <OracleSpecialDBOperation>
#
sqlstore.database.oracle.defineCol=JDO76516 : \u00c9chec de la d\u00e9finition d\u2019une colonne pour l\u2019instruction.
sqlstore.database.oracle.nooracleavailable=JDO76517 : \u00c9chec de l\u2019obtention d\u2019une instance oracle.jdbc.OraclePreparedStatement ou oracle.jdbc.driver.OraclePreparedStatement lors de l\u2019initialisation de la fabrique de ressources Oracle \u2019{0}\u2019. La fonction d\u2019optimisation d\u2019Oracle va \u00eatre d\u00e9sactiv\u00e9e. Si des instances utilisant cette ressource n\u00e9cessitent des valeurs de liaison pour les colonnes mapp\u00e9es \u00e0 la colonne \u2019Fixed Char\u2019, les valeurs seront compl\u00e9t\u00e9es avec des espaces sur la longueur sp\u00e9cifi\u00e9e dans le fichier dbschema correspondant.
sqlstore.database.oracle.fixedcharpadded=JDO76518 : La valeur "{0}" est li\u00e9e \u00e0 une colonne CHAR. Une gestion particuli\u00e8re est requise pour Oracle. Compte tenu que la classe OraclePreparedStatement n\u2019a pas pu \u00eatre extraite du pilote, la valeur est compl\u00e9t\u00e9e avec des espaces sur la longueur {1}, tel qu\u2019indiqu\u00e9 dans le fichier dbschema captur\u00e9.
#
# <Misc.>
#
core.configuration.getvendortypefailed=JDO76519 : Impossible d\u2019identifier le type de fournisseur pour le magasin de donn\u00e9es.
jdo.sqlpersistencemanagerfactory.errorgettingDatabaseInfo=JDO76520 : Erreurs lors de l\u2019obtention d\u2019informations sur la base de donn\u00e9es. L\u2019exception suivante s\u2019est produite :

#
# <NOI18N: Connection>
#
sqlstore.connection.conncectiomgr.found=<--> ConnectionManager.getConnection: found {0}.
sqlstore.connection.conncectiomgr.getnewconn=<--> ConnectionManager.getConnection: new {0}.
sqlstore.connection.conncectiomgr.replacefreeconn=<--> ConnectionManager.replaceFreeConnection: free {0}.
sqlstore.connectionimpl.clearxact.close=--- ConnectionImpl.clearXact: connection closed .
sqlstore.connectionimpl.clearxact.disassocxact=--- ConnectionImpl.clearXact: disassociateXact .
sqlstore.connectionimpl.clearxact=--- ConnectionImpl.clearXact: .
sqlstore.connectionimpl.close.connrelease=<--- ConnectionImpl.close: connection released.
sqlstore.connectionimpl.close.exit=<--- ConnectionImpl.close: connection closed.
sqlstore.connectionimpl.close.freepending=<--- ConnectionImpl.close: set FreePending.
sqlstore.connectionimpl.close.putfreelist=<--- ConnectionImpl.close: put in freeList.
sqlstore.connectionimpl.close.replaced=<--- ConnectionImpl.close: connection replaced.
sqlstore.connectionimpl.close=---> ConnectionImpl.close.
sqlstore.connectionimpl.close_arg=---> ConnectionImpl.close: {0}.
sqlstore.connectionimpl.commit=--- ConnectionImpl.commit: connection closed.
sqlstore.connectionimpl.finalize=--- ConnectionImpl.finalize: connection closed.
sqlstore.connectionimpl.internalcommit=--- ConnectionImpl.internalCommit: .
sqlstore.connectionimpl.pendingdisassocxact=--- ConnectionImpl.clearXact: Pending disassociateXact.
sqlstore.connectionimpl.rollback.close=--- ConnectionImpl.rollback: connection closed.
sqlstore.connectionimpl.rollback=--- ConnectionImpl.rollback:.
#
# <NOI18N: DBVendorType>
#
sqlstore.database.dbvendor.castRequiredForNumericValues=<-> DBVendorType.isCastRequiredForNumericValues(): {0}.
sqlstore.database.dbvendor.getModFunctionName=<-> DBVendorType.getModFunctionName(): {0}.
sqlstore.database.dbvendor.getNullComparisonFunctionName=<-> DBVendorType.getNullComparisonFunctionName(): {0}.
sqlstore.database.dbvendor.getConcatCast=<-> DBVendorType.getConcatCast(): {0}.
sqlstore.database.dbvendor.getSpecialDBOperation=<-> DBVendorType.getSpecialDBOperation(): {0}.
sqlstore.database.dbvendor.getabs=<-> DBVendorType.getAbs(): {0}.
sqlstore.database.dbvendor.getcharlength=<-> DBVendorType.getCharLength(): {0}.
sqlstore.database.dbvendor.getforupdate=<-> DBVendorType.getForUpdate(): {0}.
sqlstore.database.dbvendor.getholdlock=<-> DBVendorType.getHoldlock(): {0}.
sqlstore.database.dbvendor.getisnotnull=<-> DBVendorType.getIsNotNull(): {0}.
sqlstore.database.dbvendor.getisnull=<-> DBVendorType.getIsNull(): {0}.
sqlstore.database.dbvendor.getleftjoin=<-> DBVendorType.getLeftJoin(): {0}.
sqlstore.database.dbvendor.getleftjoinpost=<-> DBVendorType.getLeftJoinPost(): {0}.
sqlstore.database.dbvendor.getleftlikeescape=<-> DBVendorType.getLeftLikeEscape(): {0}.
sqlstore.database.dbvendor.getnotequal=<-> DBVendorType.getNotEqual()\u00a0: {0}.
sqlstore.database.dbvendor.getposition3args=<-> DBVendorType.getPositionThreeArrgs(): {0}.
sqlstore.database.dbvendor.getposition=<-> DBVendorType.getPosition(): {0}.
sqlstore.database.dbvendor.getpositionin=<-> DBVendorType.getPositionIn(): {0}.
sqlstore.database.dbvendor.getpositionsrchsrc=<-> DBVendorType.getPositionSearchSource(): {0}.
sqlstore.database.dbvendor.getquotecharstart=<-> DBVendorType.getQuoteCharStart(): {0}.
sqlstore.database.dbvendor.getrightjoinipre=<-> DBVendorType.getRightJoin(): {0}.
sqlstore.database.dbvendor.getrightlikeescape=<-> DBVendorType.getRightLikeEscape(): {0}.
sqlstore.database.dbvendor.getrtrim=<-> DBVendorType.getRtrim(): {0}.
sqlstore.database.dbvendor.getrtrimpost=<-> DBVendorType.getRtrimPost(): {0}.
sqlstore.database.dbvendor.getsqrt=<-> DBVendorType.getSqrt(): {0}.
sqlstore.database.dbvendor.getstringconcat=<-> DBVendorType.getStringConcat(): {0}.
sqlstore.database.dbvendor.getsubstring=<-> DBVendorType.getSubstring(): {0}.
sqlstore.database.dbvendor.getsubstringfor=<-> DBVendorType.getSubstringFor(): {0}.
sqlstore.database.dbvendor.getsubstringfrom=<-> DBVendorType.getSubstringFrom(): {0}.
sqlstore.database.dbvendor.gettablelistend=<-> DBVendorType.getTableListEnd(): {0}.
sqlstore.database.dbvendor.gettableliststart=<-> DBVendorType.getTableListStart(): {0}.
sqlstore.database.dbvendor.isAnsiTrim=<-> DBVendorType.isAnsiTrim(): {0}.
sqlstore.database.dbvendor.isInlineNumeric=<-> DBVendorType.isInlineNumeric(): {0}.
sqlstore.database.dbvendor.isNativeOuterJoin=<-> DBVendorType.isNativeOuterJoin(): {0}.
sqlstore.database.dbvendor.isParameterCast=<-> DBVendorType.isParameterCast(): {0}.
sqlstore.database.dbvendor.isdistinctupdatelocksupported=<-> DBVendorType.isDistinctSupportedWithUpdateLock(): {0}.
sqlstore.database.dbvendor.islockcolumnlistsupported=<-> DBVendorType.isLockColumnListSupported(): {0}.
sqlstore.database.dbvendor.isupdatelocksupported=<-> DBVendorType.isUpdateLockSupported(): {0}.
sqlstore.database.dbvendor.mapemptystrtonull=<-> DBVendorType.mapEmptyStringToNull(): {0}.
sqlstore.database.dbvendor.overrideproperties.with=<-> DBVendorType.overrideProperties() : {0} with: {1}.
sqlstore.database.dbvendor.overrideproperties=<-> DBVendorType.overrideProperties() - NONE.
sqlstore.database.dbvendor.supportslikeescape=<-> DBVendorType.supportsLikeEscape(): {0}.
sqlstore.database.dbvendor.vendorname=<-> DBVendorType(), vendorName: [{0}]  vendorType: {1}.
#
# <NOI18N: TransactionImpl>
#
sqlstore.transactionimpl.call.info={0} Tran[ {1} ].{2}: {3} for  {4}.
sqlstore.transactionimpl.call={0} Tran[ {1} ].{2}:status = {3}, txType: {4} for  {5}.
sqlstore.transactionimpl.closeconnection=--- TransactionImpl.closeConnection() {0} for {1}.
sqlstore.transactionimpl.general={0}.
sqlstore.transactionimpl.getconnection=--- TransactionImpl.getConnection(): {0} TX optimistic: {1} referenceCount = {2} for {3}.
sqlstore.transactionimpl.releaseconnection=--- TransactionImpl.releaseConnection(): TX optimistic: {0} Inside Commit: {1} referenceCount: {2} for {3}.
sqlstore.transactionimpl.rollbackconnection=--- TransactionImpl.rollbackConnection(): {0} for {1}.
sqlstore.transactionimpl.status={0} Tran[ {1} ].setStatus: {2} => {3} for {4}.


###############################################################################
# All the source files under subdir ejb.
# Message ID Range: JDO76600 - JDO76699
###############################################################################
#
#EJBHelper messages
#
# {0} - method name
ejb.ejbhelper.nonmanaged=JDO76600 : Il ne faut pas faire appel \u00e0 la m\u00e9thode {0} dans un environnement qui n\u2019est pas g\u00e9r\u00e9.

#
# Common messages between SunContainerHelper and DeploymentHelper
# so they have a neutral key, that still starts with "ejb".
#
# {0} - jndi name.
ejb.jndi.lookupfailed=JDO76604 : \u00c9chec de la recherche JNDI d\u2019une ressource CMP \u2019{0}\u2019.
JDO76604.diag.cause.1=La ressource CMP portant ce nom JNDI n\u2019est pas enregistr\u00e9e dans cette instance.
JDO76604.diag.cause.1=La ressource CMP portant ce nom JNDI n\u2019est pas enregistr\u00e9e dans cette instance.
JDO76604.diag.check.1=V\u00e9rifiez le nom JNDI de la ressource \u00e0 utiliser.
JDO76604.diag.check.2=V\u00e9rifiez le nom JNDI de la ressource CMP sp\u00e9cifi\u00e9e dans le module.

# {0} - jndi name.
# {1} - returned class name.
ejb.jndi.unexpectedinstance=JDO76605 : La recherche JNDI d\u2019une ressource CMP \u2019{0}\u2019 a renvoy\u00e9 une instance de type inattendu : {1}.
JDO76605.diag.cause.1=La ressource CMP portant ce nom JNDI ne fait pas r\u00e9f\u00e9rence \u00e0 la ressource jdbc-resource ou persistence-manager-factory-resource.
JDO76604.diag.cause.1=La ressource CMP portant ce nom JNDI n\u2019est pas enregistr\u00e9e dans cette instance.
JDO76604.diag.check.1=V\u00e9rifiez le nom JNDI de la ressource \u00e0 utiliser.
JDO76604.diag.check.2=V\u00e9rifiez le nom JNDI de la ressource CMP sp\u00e9cifi\u00e9e dans le module.

#
# DeploymentHelper messages - ejb
#
#
#<NOI18N: DeploymentHelper>
#
ejb.DeploymentHelper.getconnection=Getting connection for JNDI name ''{0}''.

# The messages JDO76606 through JDO76615 that were originally here 
# have been moved to 
# cmp/support/ejb/src/com/sun/jdo/spi/persistence/support/ejb/ejbc/Bundle.properties
# As part of INF#
# So do not use these messages. 


#
#CMPHelper messages
#
ejb.cmphelper.nonmanaged=JDO76613 : Acc\u00e8s non valide \u00e0 CMPHelper. Cette classe est utilis\u00e9e pour la prise en charge CMP uniquement et ne doit pas \u00eatre appel\u00e9e en dehors du serveur d\u2019applications.

#
#SunTransactionHelper messages
#

# {0} class name
ejb.SunTransactionHelper.wrongdatasourcetype=JDO76616 : DataSource ne correspond pas au type attendu. Attendu : com.sun.appserv.jdbc.DataSource, obtenu : {0}.


###############################################################################
# <Generic messages. Add new messages to this section only if none of the above categories can be used.>
###############################################################################
#
# <NOI18N: generic>
#
vendor=Sun Microsystems
# majorVersion (minorVersion) buildDate
fullVersion={0} ({1}) {2}
#
# <NOI18N: This messages are used for JDOFatalInternalException from multiple places. No need to I18N>
#
core.generic.unknownfield=The field {0} is not a member of the class {1}.
core.generic.unknownexception=Got an unknown exception.
core.generic.nullparam=The {0} parameter is null.
core.generic.notinstanceof=The object of class {0} is not an instance of {1}.


###############################################################################
# <These messages are used from multiple places in code.It is absolutely necessary to cleanup code
# to use different messages >
###############################################################################
core.configuration.cantloadclass=Echec du chargement de la classe {0}.
sqlstore.exception.log=Exception.
jdo.lifecycle.deleted.accessField=Impossible d\u2019acc\u00e9der au champ d\u2019une instance supprim\u00e9e.
