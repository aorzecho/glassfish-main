#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2010 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

# Resource bundle for sqlstore runtime messages
# key consists of: <subpackage>.<class>.<method>.<description>
# <subpackage> - is optional, package under runtime
# <class> - class name
# <method> - method name
# <description> - short description (use _ to represent space)
# all keys should be in lowercase
#
# Please note that many package names and classnames have changed over time.
# Unfortunately, this file was not maintained to follow above convention.
# Please ignore if the package/class name does not match actual names as today.
#
#
# The message ID for a message in persistence is derived as follows:
# JDO<2_digit_bundle_prefix><1_digit_section_number><2_digit_serial_number>
#
# The 2 digit prefix for this bundle is 76.
#
# This file is divided into the following sections:
# Under each section, messages that need not be I18Ned are separated under NOI18N. All other messages
# need to be numbered.
# 1. JDO:  PersistenceManagerFactory/PersistenceManager/ExtentCollection/LifeCycle
# 2. Model
# 3. StateManager
# 4. sql generator components: RetrieveDesc, ResultDesc plus all the files under generator subdir
# 5. SQLStoreManager
# 6. Connection/Connectionpool/Transaction/DBVendorType
# 7. EJB integration.
# 8. Generic messages.
#
# When adding a new message:
# 1. Please make sure that you add the message to the end of appropriate section.
# 2. Please add message ID to any user visible message.
# 3. The message ID for the new message = message ID for the last numbered
#    message in a section + 1.
# 4. Please do not change the message ID for existing messages. These
#    numbers are potentially mapped to more explanation about the message for
#    the end user.
#

####################################################################################################
# <All the source files under subdir impl (PersistenceManagerFactory/PersistenceManager etc.) >
# Message ID Range: JDO76000 - JDO76099
####################################################################################################
jdo.persistencemanagerfactoryimpl.getpersistencemanager.error=JDO76000: impossibile utilizzare pi\u00f9 combinazioni di nome utente/password nella stessa transazione.
jdo.persistencemanagerfactoryimpl.getpersistencemanager.notconfigured=JDO76001: PersistenceManagerFactory non configurato.
jdo.persistencemanagerfactoryimpl.notsupported=JDO76002: l''operazione non \u00e8 supportata per il PersistenceManagerFactoryImpl interno.
jdo.persistencemanagerimpl.acquireexclusivelock.interrupted=JDO76003: impossibile acquisire il lock esclusivo a causa di InterruptedException
jdo.persistencemanagerimpl.acquiresharelock.failed=JDO76004: impossibile acquisire il lock condiviso perch\u00e9 _readWriteCount \u00e8 inferiore a zero
jdo.persistencemanagerimpl.acquiresharelock.interrupted=JDO76005: impossibile acquisire il lock condiviso a causa di InterruptedException
jdo.persistencemanagerimpl.another_pm=JDO76006: oggetto associato a un altro PersistenceManager.
jdo.persistencemanagerimpl.assertactivetransaction.error=JDO76007: la transazione associata a questa gestione della persistenza non \u00e8 attiva.
jdo.persistencemanagerimpl.assertclosed.closed=JDO76008: PersistenceManager \u00e8 chiuso.
jdo.persistencemanagerimpl.assertpersistencecapable.error=JDO76009: la classe {0} non \u00e8 stata ottimizzata per la trasparenza persistente. Usare il packager JAR o WAR dell''IDE per creare un pacchetto delle classi con funzionalit\u00e0 di persistenza prima dell''esecuzione. In alternativa, impostare la propriet\u00e0 Executor della classe principale su Persistence Executor per l''esecuzione dall''IDE.
jdo.persistencemanagerimpl.close.activetransaction=JDO76010: \u00e8 presente una transazione aperta associata a questa gestione della persistenza.
jdo.persistencemanagerimpl.fetchinstance.none=JDO76012: oggetto non trovato per questo ObjectId.
jdo.persistencemanagerimpl.internaldeletepersistent.transient=JDO76014: impossibile eliminare oggetto non persistente.
jdo.persistencemanagerimpl.internalmakepersistent.dups=JDO76015: un''istanza con la stessa chiave primaria esiste gi\u00e0 nella cache di PersistenceManager.
jdo.persistencemanagerimpl.loadclassforoid.wrongoidclass=JDO76016: errore nel recupero della classe di oggetto da OID.
jdo.persistencemanagerimpl.newscoinstance.wrongclass=JDO76017: impossibile creare istanza SCO della classe {0} perch\u00e9 il tipo non \u00e8 valido.
jdo.persistencemanagerimpl.notprocessed=JDO76018: impossibile cancellare istanze persistenti a causa di dipendenze circolari.
jdo.persistencemanagerimpl.releaseexclusivelock.failed=JDO76019: impossibile rilasciare il lock esclusivo perch\u00e9 _readWriteCount \u00e8 maggiore di zero
jdo.persistencemanagerimpl.releasesharelock.failed=JDO76020: impossibile rilasciare il lock condiviso perch\u00e9 _readWriteCount \u00e8 pari a zero
jdo.persistencemanagerwrapper.invalidpm=JDO76021: PersistenceManagerWrapper \u00e8 chiuso.
jdo.extentcollection.constructor.invalidclass=JDO76022: classe ''{0}'' non valida per la raccolta di estensioni.
jdo.extentcollection.constructor.nonpc=JDO76023: la classe ''{0}'' non ha funzionalit\u00e0 di persistenza.
jdo.extentcollection.constructor.subclasses=JDO76024: sottoclassi di opzioni true non \u00e8 supportato per le raccolte di estensioni.
jdo.extentcollection.illegalmodification=JDO76025: modifica non valida della raccolta di estensioni per la classe ''{0}''.
jdo.extentcollection.methodnotsupported=JDO76026: metodo {0} di raccolta delle estensioni non supportato.
jdo.lifecycle.xactnotactive=JDO76027: \u00e8 necessaria una transazione attiva per eseguire questa operazione.
jdo.persistencemanagerimpl.newinstance.badsm=JDO76028: configurazione di StateManager non completa.
jdo.persistencemanagerimpl.setjtatransaction.notnulljta=JDO76029: tentativo di sostituire javax.transaction.Transaction: {0} non nulla con {1}.
jdo.persistencemanagerfactoryimpl.getpersistencemgr.closed=JDO76030: PersistenceManager per questa javax.transaction.Transaction: {0} \u00e8 gi\u00e0 chiuso o in fase di commit.
jdo.persistencemanagerfactoryimpl.registerpm.registered=JDO76031: questa istanza di javax.transaction.Transaction: {0} \u00e8 gi\u00e0 registrata con un altro PersistenceManager: {1}.
jdo.persistencemanagerimpl.verificationfailed=JDO76032: verifica dell''istanza di coerenza delle versioni a fronte del data store non riuscita.
jdo.persistencemanagerfactoryimpl.getversionconsistencycache.nullstore=JDO76033: StoreManager non configurato.

#
# <NOI18N: LifeCycle>
#
sqlstore.state.lifecyclestate.changestate=LifeCycleState.changeState(), old state = {0}, new state = {1}.
sqlstore.state.lifecyclestate.initial=LifeCycleState.getLifeCycleState(), initial state = {0}.

#
# <NOI18N: PersistenceManager>
#
sqlstore.persistencemgr.acquireexclusivelock.count=acquireExclusiveLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.acquireexclusivelock=acquireExclusiveock(), thread {0} going to wait.
sqlstore.persistencemgr.acquiresharedlock.rdwrcount=acquireShareLock(), thread {0} acquired shared lock with _readWriteCount ={1}.
sqlstore.persistencemgr.acquiresharedlock=acquireShareLock(), thread {0} going to wait.
sqlstore.persistencemgr.aftercompletion.process=---PersistenceManagerImpl.afterCompletion() process: {0}.
sqlstore.persistencemgr.aftercompletion=---PersistenceManagerImpl.afterCompletion() abort: {0}.
sqlstore.persistencemgr.assertactivetx.closed=--- PersistenceManagerImpl.assertActiveTransaction: Closed for  {0}.
sqlstore.persistencemgr.assertactivetx=--- PersistenceManagerImpl.assertActiveTransaction:  {0}.
sqlstore.persistencemgr.assertisopen=--- PersistenceManagerImpl.assertIsOpen: CLOSED for {0}.
sqlstore.persistencemgr.beforecompletion=---PersistenceManagerImpl.beforeCompletion().
sqlstore.persistencemgr.cacheproperties=PersistenceManagerImpl cache properties: _txCacheInitialCapacity={0}, _flushedCacheInitialCapacity={1}, _flushedCacheLoadFactor={2}, _weakCacheInitialCapacity={3}, _weakCacheLoadFactor={4}.
sqlstore.persistencemgr.deregisterinstance.verified=---PersistenceManagerImpl.deregisterInstance() -- deregistered with verify.
sqlstore.persistencemgr.deregisterinstance.verify=---PersistenceManagerImpl.deregisterInstance() with verify SM -- oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.deregisterinstance=---PersistenceManagerImpl.deregisterInstance() oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getbyobjid=---PersistenceManagerImpl.getObjectById() OID:{0}  for PersistenceManager: {1} and JTA: {2}.
sqlstore.persistencemgr.getcurrentwrapper=---PersistenceManagerImpl.getCurrentWrapper() > current: {0}.
sqlstore.persistencemgr.getobjid.notpc=---PersistenceManagerImpl.getObjectId() NOT PC: {0}  for PersistenceManager: {1}.
sqlstore.persistencemgr.getobjid.notpm=---PersistenceManagerImpl.getObjectId() NOT PM: {0} for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getobjid= :{0} ---PersistenceManagerImpl.getObjectId() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.internalcloneoid.old=---PersistenceManagerImpl.internalCloneOid(): old: {0}  new: {1} same: {2}.
sqlstore.persistencemgr.internalcloneoid=---PersistenceManagerImpl.internalCloneOid() ERROR: {0}.
sqlstore.persistencemgr.isactivetx=---PersistenceManagerImpl.isActiveTransaction() : {0}.
sqlstore.persistencemgr.isnontxread=---PersistenceManagerImpl.isNontransactionalRead() : {0}.
sqlstore.persistencemgr.isoptimistic=---PersistenceManagerImpl.isOptimisticTransaction() : {0}.
sqlstore.persistencemgr.loadingclass=Loading ... ClassName: {0}.
sqlstore.persistencemgr.loadingfile=Loading ... FileName: {0} {1} {2}.
sqlstore.persistencemgr.makepersistent.done=---PersistenceManagerImpl.makePersistent() {0}  finished for: {1}  and JTA: {2}.
sqlstore.persistencemgr.makepersistent= {0} ---PersistenceManagerImpl.makePersistent() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.newcollection=---PersistenceManagerImpl.newCollectionInstanceInternal() type: {0}.
sqlstore.persistencemgr.popcurrentwrapper=---PersistenceManagerImpl.popCurrentWrapper() > current: {0}  prev: {1}.
sqlstore.persistencemgr.pushcurrentwrapper=---PersistenceManagerImpl.pushCurrentWrapper() > current: {0}  new: {1}.
sqlstore.persistencemgr.registerinstance= {0} ---PersistenceManagerImpl.registerInstance() oid/sm: {1}/{2}  for PersistenceManager: {3}  and JTA: {4}.
sqlstore.persistencemgr.registerinstancein_txc=registerInstance in TXC :{0} / {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.registerinstancein_wkc=registerInstance in WKC.
sqlstore.persistencemgr.releaseexclusivelock=releaseExclusiveock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.releasesharedlock=releaseShareLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.replacingdeletedinstance=Replacing deleted instance with new for Object Id: {0}.
sqlstore.persistencemgr.setkeyfields=---PersistenceManagerImpl.setKeyFields() ERROR: {0}.
#
# <NOI18N: PersistenceManagerFactory>
#
sqlstore.sqlpersistencemgrfactory.getfrompool.pmt=<--SQLPersistenceManagerFactory.getFromPool() PM: {0} for JTA {1}.
sqlstore.sqlpersistencemgrfactory.getfrompool=<--SQLPersistenceManagerFactory.getFromPool().
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.found= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() FOUND javax.transaction.Transaction: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx.notfound=<->SQLPersistenceManagerFactory.getPersistenceManager() NOT FOUND JDO Transaction:.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx=<->SQLPersistenceManagerFactory.getPersistenceManager() JDO Transaction: {0}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmclosedfor= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() PM is CLOSED FOR: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmt= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() : {1} for JTA: {2}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr=:{0} -->SQLPersistenceManagerFactory.getPersistenceManager().
sqlstore.sqlpersistencemgrfactory.init=---SQLPersistenceManagerFactory.initialize().
sqlstore.sqlpersistencemgrfactory.pmCacheBucketSize=---SQLPersistenceManagerFactory pmCacheBucketSize = {0}.
sqlstore.sqlpersistencemgrfactory.pmCacheInitialCapacity=---SQLPersistenceManagerFactory pmCacheInitialCapacity = {0}.
sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt=<->SQLPersistenceManagerFactory.registerPersistenceManager() PM: {0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.releasepm.pmt=---SQLPersistenceManagerFactory.releasePersistenceManager() PM:{0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.returnToPool=<--SQLPersistenceManagerFactory.returnToPool().


###############################################################################
# <Model>
# Message ID Range: JDO76100 - JDO76199
###############################################################################
core.configuration.columnnotable=JDO76100: il descrittore della colonna non presentava un descrittore tabella valido.
core.configuration.fieldnotable=JDO76101: il campo {0} non \u00e8 associato ad alcuna tabella.
core.configuration.fieldnotmapped=JDO76102: il campo persistente {0} per la classe {1} non \u00e8 mappato.
core.configuration.iddescnofield=JDO76103: l''oggetto SqlIDDesc non \u00e8 stato impostato correttamente. Nessun descrittore di campo disponibile.
core.configuration.loadfailed.class=JDO76104: impossibile caricare la configurazione per la classe {0}.
core.configuration.noneexistentpkfield=JDO76105: il campo {0} nella classe ObjectId {1} non esiste nella classe PersistenceCapable {2}.
core.configuration.unsupportedconsistencylevel=JDO76106: la classe {0} ha un livello di coerenza non supportato. I livelli di coerenza correntemente supportati sono "none", "check-modified-at-commit", "lock-when-loaded" e "check-version-of-accessed-instances".
core.configuration.validationfailed=JDO76107: il mapping per la classe {0} non \u00e8 valido:\n{1}.
core.configuration.validationproblem=JDO76108: errore di convalida nella classe {0}: {1}
#
# <FieldDesc validation at runtime>
#
core.fielddesc.minvalue=JDO76109: il valore: {0} \u00e8 inferiore al minimo consentito: {1} per il tipo di campo {2}.
core.fielddesc.maxvalue=JDO76110: il valore: {0} \u00e8 superiore al massimo consentito: {1} per il tipo di campo {2}.
core.configuration.noneexistentvcfield=JDO76111: il campo {0} \u00e8 contrassegnato come campo versione ma non esiste nella classe PersistenceCapable {1}.
core.configuration.loadfailed.field=JDO76112: impossibile caricare la configurazione per il campo {0} nella classe {1}.

#
# <NOI18N: model>
#
sqlstore.model.classdesc.assocrelatedfield=associated relationship field = {0}.
sqlstore.model.classdesc.createsqldesc=creating SqlIDDesc from {0}.
sqlstore.model.classdesc.fieldinfo=field name = {0}, id= {1}.
sqlstore.model.classdesc.general={0}.{1} =>{2}
sqlstore.model.classdesc.getlocalfielddesc=<-> SqlPersistenceDesc.getLocalFieldDesc(), class ={0} added hidden field {1}  for column {2}.
sqlstore.model.classdesc.loadedclass=Successfully loaded oid class= {0}.
sqlstore.model.classdesc.persistconfiginit.exit=<-- SqlPersistenceConfig.initialize().
sqlstore.model.classdesc.persistconfiginit=--> SqlPersistenceConfig.initialize(), class = {0}.
sqlstore.model.classdesc.pkfield=PK field = {0}.
sqlstore.model.classdesc.primarytrackedfield=field {0} is the primary tracked field .
sqlstore.model.classdesc.unsetconcurrencychk=unsetting IN_CONCURRENCY_CHECK property for lf  {0}.
sqlstore.model.classdesc.unsetrefintegrityupdate=unsetting REF_INTEGRITY_UPDATES property for ff {0}.
sqlstore.model.classdesc.vcfield=Version consistency field = {0}.
sqlstore.model.fielddesc.addingfield=adding field {0} to be tracked by field {1}.
sqlstore.model.fielddesc.convertvalue.from_to=convertValue: {0} From: {1} To: {2}.
sqlstore.model.fielddesc.convertvalue.hidden=convertValue: hidden {0} ... return.
sqlstore.model.fielddesc.convertvalue=convertValue: NULL ... return.
sqlstore.model.fielddesc.fieldname={0} = {1}.
sqlstore.model.fielddesc.setupdesc=setupDesc(): fieldName {0} fieldType {1}.
sqlstore.model.configcacheimpl.size_before={0} size before cleanup: {1}.
sqlstore.model.configcacheimpl.size_after={0} size after cleanup: {1}.


###############################################################################
# <StateManager>
# Message ID Range: JDO76200 - JDO76299
###############################################################################
core.statemanager.anotherowner=JDO76200: impossibile assegnare istanza SCO posseduta da un altro oggetto.
core.statemanager.cantnewoid=JDO76201: impossibile creare una nuova istanza di chiave primaria della classe {0}.
core.statemanager.cantschedulejointable=JDO76202: impossibile pianificare la voce della tabella dei collegamenti tra la classe {0} e {1} perch\u00e9 la descrizione del campo relazione \u00e8 nulla.
core.statemanager.cantsetkeyfield=JDO76203: impossibile impostare il valore per il campo chiave primaria {0}.
core.statemanager.conflictingvalues=JDO76204: valori in conflitto tra il campo {0} e il campo {1} che sono mappati nella stessa colonna
core.statemanager.getfieldfailed=JDO76205: impossibile ottenere il campo.
core.statemanager.invalidpk=JDO76206: campo chiave primaria nullo non valido {0} quando viene ricaricata un''istanza di una classe con funzionalit\u00e0 di persistenza {1}. L''ObjectId dell''istanza \u00e8 {2}.
core.statemanager.nopkupdate=JDO76207: aggiornamento di un campo chiave primaria non consentito.
core.statemanager.nopm=JDO76208: la gestione dello stato non contiene riferimenti alla gestione della persistenza.
core.statemanager.notnavigable=JDO76209: si \u00e8 verificato un tentativo di accedere al campo {0} della classe {1}.  Il campo non \u00e8 stato referenziato in precedenza e questa classe non consente la navigazione dinamica.  \u00c8 necessario richiedere il campo al momento del recupero della classe oppure consentire la navigazione dinamica cos\u00ec da permettere il recupero automatico all''accesso.
core.statemanager.objectnotfound=JDO76210: l''oggetto non esiste nel data store.
core.statemanager.poshiddenindex=JDO76211: l''indice di un campo nascosto deve essere negativo, ma \u00e8 stato ottenuto un indice di {0}.
core.statemanager.readonly=JDO76212: \u00e8 stato eseguito un tentativo di modificare il campo di sola lettura {0} della classe {1}.
core.statemanager.releaselock.wrongthread=JDO76213: questo thread {0} non contiene il lock StateManager.
core.statemanager.setfieldfailed=JDO76214: impossibile impostare il campo.
core.statemanager.wrongusageforoverlappingpkfkdelete=JDO76215: tentativo non corretto di eliminare un''istanza da una relazione gestita. La relazione \u00e8 definita da una colonna chiave primaria sull''altro lato. Le operazioni di eliminazione su una raccolta richiedono l''aggiornamento della colonna sull''altro lato, ma l''aggiornamento della chiave primaria non \u00e8 consentito. Per questo motivo, l''eliminazione di un''istanza da una raccolta di relazioni gestite definita da una chiave primaria pu\u00f2 essere eseguita solo eliminando l''istanza, in modo esplicito o con eliminazione a cascata.
core.statemanager.toomanyrows=JDO76215: \u00e8 stata restituita pi\u00f9 di una riga per una delle tabelle mappate alla classe {0}.  Ogni tabella mappata a una classe deve avere solo una riga per ogni istanza dell''oggetto.
core.statemanager.copyFields.mismatch=JDO76216: tentativo di copia di campi tra StateManager che gestiscono istanze di tipi diversi: {0} e {1}.

#
# <NOI18N: StateManager>
#
sqlstore.sqlstatemanager.adddependency=<-> SQLStateManager.addDependency(), this StateManager: {0}, other StateManager: {1}.
sqlstore.sqlstatemanager.addupdate=<-> SQLStateManager.addUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.applyupdates.exit=<-- SqlStateManager.applyUpdates().
sqlstore.sqlstatemanager.applyupdates=--> SqlStateManager.applyUpdates(), field = {0}.
sqlstore.sqlstatemanager.clearpersistencefields.exit=<--- SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.clearpersistencefields=--> SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.copychanges.exit=<-- SQLStateManager.copyChanges().
sqlstore.sqlstatemanager.copychanges=--> SQLStateManager.copyChanges(), state manager = {0}.
sqlstore.sqlstatemanager.deletepersistence=<-> SqlStateManager.deletePersistence(), type = {0}.
sqlstore.sqlstatemanager.getbeforeimage.exit=<-- SqlStateManager.getBeforeImage().
sqlstore.sqlstatemanager.getbeforeimage=--> SqlStateManager.getBeforeImage(), type = {0}.
sqlstore.sqlstatemanager.isbeforeimagerequired=isBeforeImageRequired is : {0}.
sqlstore.sqlstatemanager.loadforread.exit=<-- SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforread=--> SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforupdate.exit=<-- SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loadforupdate=--> SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loggingfield=logging field = {0} with value = {1}.
sqlstore.sqlstatemanager.makedirty.fixscocollection=--- SqlStateManager.makeDirty(), fix SCOCollection.
sqlstore.sqlstatemanager.makedirty.fixscodate=--- SqlStateManager.makeDirty(), fix SCODate.
sqlstore.sqlstatemanager.makedirty=--> SqlStateManager.makeDirty(), field = {0}.
sqlstore.sqlstatemanager.makedirtyfield=marked dirty field = {0}.
sqlstore.sqlstatemanager.makepersistence=<-> SqlStateManager.makePersistence(), type = {0}.
sqlstore.sqlstatemanager.makepresent=--> SqlStateManager.makePresent(), field = {0}.
sqlstore.sqlstatemanager.marking=marking: {0} as present.
sqlstore.sqlstatemanager.newtype=New Type: {0}.
sqlstore.sqlstatemanager.nosuchmethodexcep.clone=Exception : {0}  clone ... for type {1}.
sqlstore.sqlstatemanager.preparegetfield.exit=<-- SqlStateManager.prepareGetField().
sqlstore.sqlstatemanager.preparegetfield=--> SqlStateManager.prepareGetField(), name = {0}.
sqlstore.sqlstatemanager.preparesetfield.exit=<-- SQLStateManager.prepareSetField().
sqlstore.sqlstatemanager.preparesetfield=--> SQLStateManager.prepareSetField(), name = {0}.
sqlstore.sqlstatemanager.preparetoupdateph1.exit=<-- SqlStateManager.prepareToUpdateI().
sqlstore.sqlstatemanager.preparetoupdateph1=--> SqlStateManager.prepareToUpdatePhaseI(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph2.exit=<-- SqlStateManager.prepareToUpdateII().
sqlstore.sqlstatemanager.preparetoupdateph2=--> SqlStateManager.prepareToUpdatePhaseII(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph3.exit=<-- SqlStateManager.prepareToUpdateIII().
sqlstore.sqlstatemanager.preparetoupdateph3=--> SqlStateManager.prepareToUpdatePhaseIII(), type = {0}.
sqlstore.sqlstatemanager.prepareupdatefield.exit=<-- SQLStateManager.prepareUpdateField().
sqlstore.sqlstatemanager.prepareupdatefield=--> SQLStateManager.prepareUpdateField(), name = {0} for state: {1}.
sqlstore.sqlstatemanager.prepareupdatefieldspl.exit=<-- SQLStateManager.prepareUpdateFieldSpecial().
sqlstore.sqlstatemanager.prepareupdatefieldspl=--> SQLStateManager.prepareUpdateFieldSpecial, name = {0} for state: {1}.
sqlstore.sqlstatemanager.processcollectionupdate.exit=<-- SQLStateManager.processCollectionUpdates().
sqlstore.sqlstatemanager.processcollectionupdate=--> SQLStateManager.processCollectionUpdates(), beforeList={0}, afterlist={1}.
sqlstore.sqlstatemanager.processforeign=process foreign field ={0}.
sqlstore.sqlstatemanager.processforeignfield.remove=-- SQLStateManager.processForeignField(): was Collection - remove.
sqlstore.sqlstatemanager.processforeignfield.remove_from_bi=-- SQLStateManager.processForeignField(): is SCOCollection - remove from BI.
sqlstore.sqlstatemanager.processforeignfield.reset=-- SQLStateManager.processForeignField(): was SCOCollection - reset.
sqlstore.sqlstatemanager.processforeignfield=-- SQLStateManager.processForeignField(): value: {0} type: {1}.
sqlstore.sqlstatemanager.realizefield.exit=<-- SqlStateManager.realizeField().
sqlstore.sqlstatemanager.realizefield=--> SqlStateManager.realizeField(), name = {0}.
sqlstore.sqlstatemanager.realizeforeignfield.exit=<-- SqlStateManager.realizeField(), field realized = {0}.
sqlstore.sqlstatemanager.realizeforeignfield=--> SqlStateManager.realizeField(), name = {0}.
sqlstore.sqlstatemanager.recordingfield=recording field = {0}.
sqlstore.sqlstatemanager.refreshpersistent.exit=<-- SqlStateManager.refreshPersistent().
sqlstore.sqlstatemanager.refreshpersistent=--> SqlStateManager.refreshPersistence(), type = {0}.
sqlstore.sqlstatemanager.reload.exit=<-- SqlStateManager.reload(FieldDesc).
sqlstore.sqlstatemanager.reload=--> SqlStateManager.reload(FieldDesc), type = {0}, field = {1}.
sqlstore.sqlstatemanager.removeupdate=<-> SQLStateManager.removeUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.replaceobjectfield.unsetsco=-- SqlStateManager.replaceObjectField(), unset SCO.
sqlstore.sqlstatemanager.replaceobjectfield=-- SqlStateManager.replaceObjectField(), field = {0}, type= {1}.
sqlstore.sqlstatemanager.reset=--> SqlStateManager.reset(), retValues = {0}, wasNew: {1}, keepState: {2}.
sqlstore.sqlstatemanager.resettingcollection=Resetting Collection.
sqlstore.sqlstatemanager.resettingdate=Resetting Date.
sqlstore.sqlstatemanager.resolvedependencies=<-> SQLStateManager.resolveDependencies(), obj={0}.
sqlstore.sqlstatemanager.resolvedependency=<-> SQLStateManager.resolveDependency(), dependency resolved: lobj={0}, f={1}, fobj={2}.
sqlstore.sqlstatemanager.retrieve.exit=<-- SqlStateManager.retrieve().
sqlstore.sqlstatemanager.retrieve=--> SqlStateManager.retrieve(), name = {0}.
sqlstore.sqlstatemanager.retrieveforeign.exit=<-- SqlStateManager.retrieveForeign().
sqlstore.sqlstatemanager.retrieveforeign=--> SqlStateManager.retrieveForeign(), name = {0}.
sqlstore.sqlstatemanager.unsetmask=unsetting masks for field = {0}.
sqlstore.sqlstatemanager.unconditionalreload.exit=<-- SqlStateManager.reload().
sqlstore.sqlstatemanager.unconditionalreload=--> SqlStateManager.reload(), type = {0}.
sqlstore.sqlstatemanager.updatebeforeimage=<-> SQLStateManager.updateBeforeImage(), name = {0}, value = {1}.
sqlstore.sqlstatemanager.updateobjfield.exit=<-- SQLStateManager.updateObjectField().
sqlstore.sqlstatemanager.updateobjfield=--> SQLStateManager.updateObjectField(), name = {0}, type = {1}.
sqlstore.sqlstatemanager.updatepersistent.exit=<-- SqlStateManager.updatePersistent().
sqlstore.sqlstatemanager.updatepersistent.immediateflush=<--> SqlStateManager.updatePersistent(), immediate flush required: obj={0}, next={1}.
sqlstore.sqlstatemanager.updatepersistent.skipped=<--> SqlStateManager.updatePersistent() skipped, type ={0}, obj= {1}.
sqlstore.sqlstatemanager.updatepersistent=--> SqlStateManager.updatePersistent(), type = {0}.
sqlstore.sqlstatemanager.updatetrackedfields.exit=<-- updateTrackedFields().
sqlstore.sqlstatemanager.updatetrackedfields=--> updateTrackedFields(), f = {0} value = {1}  fieldToIgnore = {2}.


###############################################################################
# <sql generator components: All the source files under sql.>
# Message ID Range: JDO76300 - JDO76399
###############################################################################
core.constraint.duporderby=JDO76300: il vincolo \u00e8 di tipo \"order by\" per il campo {0} che \u00e8 gi\u00e0 specificato in un vincolo \"order by\".
core.constraint.fielddisallowed=JDO76301: il parametro fieldName \u00e8 stato specificato, ma ci\u00f2 non \u00e8 consentito con l''operazione {0}.
core.constraint.fieldrequired=JDO76302: il parametro fieldName \u00e8 mancante, ma l''operazione {0} richiede un campo.
core.constraint.illegalParameterInfo=JDO76303: addConstraint() per OP_PARAMETER deve essere invocato con valore di tipo ParameterInfo.
core.constraint.illegalnode=JDO76304: nodo di vincolo non valido {0} nello stack SqlConstraint.
core.constraint.illegalop=JDO76305: il parametro dell''operazione conteneva un valore di {0} non valido.
core.constraint.needfieldnamenode=JDO76306: errore nello stack del vincolo. \u00c8 previsto un nome di campo.
core.constraint.needfieldnode=JDO76307: errore nello stack del vincolo.  \u00c8 prevista una descrizione di campo.
core.constraint.needvalnode=JDO76308: errore nello stack del vincolo. \u00c8 previsto un valore.
core.constraint.stackempty=JDO76309: lo stack del vincolo \u00e8 vuoto -- valori non sufficienti per il numero dell''operatore.
core.constraint.unknownfield=JDO76310: il campo {0} specificato nel descrittore di recupero non \u00e8 un membro della classe {1}.
core.constraint.valdisallowed=JDO76311: il parametro fieldName \u00e8 stato specificato, ma non \u00e8 consentito con l''operazione {0}.
core.constraint.valrequired=JDO76312: parametro valore mancante, ma l''operazione {0} richiede un valore.
sqlstore.resultdesc.errorgettingvalefromresulset=JDO76313: errore nell''ottenimento del valore da resultset all''indice {0} come resultType {1}. columnSqlType {2}. Eccezione: {3}
sqlstore.resultdesc.foreignfieldprojection=JDO76314: le ricerche relative a {0} non devono avere proiezioni su un campo relazione.
sqlstore.resultdesc.unknownfieldtype=JDO76317: riscontrato tipo di campo sconosciuto {0}.
sqlstore.retrievedesc.toomanyprojections=JDO76318: impossibile impostare pi\u00f9 di una proiezione per una RetrieveDesc.
sqlstore.retrievedesc.toomanyresulttypes=JDO76319: impossibile impostare pi\u00f9 di un tipo di risultato per una RetrieveDesc.
sqlstore.selectstatement.noupdatelocksupport=JDO76320: uno dei tipi di oggetto previsti in questa ricerca \u00e8 al livello di coerenza "lock-when-loaded". L''applicazione di questo livello di coerenza richiede che il data store supporti il blocco per l''aggiornamento a livello di riga. Il data store non supporta il blocco per l''aggiornamento a livello di riga.
sqlstore.sql.generator.statement.likeescapenotsupported=JDO76321: la clausola LIKE ESCAPE non \u00e8 supportata in questo database.
sqlstore.sql.generator.statement.positionthreeargsnotsupported=JDO76322: il terzo argomento per la clausola POSITION deve essere 1.
core.configuration.classnotmapped=JDO76323: la classe {0} non \u00e8 mappata.
core.configuration.classnotmappedtotable=JDO76324: la classe {0} non \u00e8 mappata alla tabella {1}.
sqlstore.sql.generator.statement.unexpectedconstraint=JDO76325: un vincolo per un''operazione {0} non pu\u00f2 mai essere la radice di una clausola where.

# <I18N: sql generator>
# Following messages are used within other messages. They need to be i18ned but need not be numbered.
#
sqlstore.sql.generator.statement.sqlStatement=Comando SQL
sqlstore.sql.generator.statement.withinputvalues= con valori immessi:
sqlstore.sql.generator.statement.withnoinputvalues= senza valori immessi.


#
# <ResultDesc NOI18N>
#
sqlstore.resultdesc.deserializing=deserializing = {0}.
sqlstore.resultdesc.marking_field=marking local field {0} as present.
sqlstore.resultdesc.marking_foreign_field=marking foreign field {0} as present.
sqlstore.resultdesc.marking_key_field=marking key field {0} as present.
sqlstore.resultdesc.returning_field=returning field {0} as projection.
#
# <Misc. SQLStore NOI18N >
#
sqlstore.sql.concurrency.concurrencychkdirty.exit=--> ConcurrencyCheckDirty.update().
sqlstore.sql.concurrency.concurrencychkdirty=--> ConcurrencyCheckDirty.update(), beforeImage = {0}.
sqlstore.sql.concurrencyoptverify.resumetx=<--> ConcurrencyOptVerify.resume(), resumed transaction = {0}.
sqlstore.sql.concurrencyoptverify.suspendtx=<--> ConcurrencyOptVerify.suspend(), suspended transaction = {0}.
sqlstore.sql.concurrencyoptverify.update.exit=<-- ConcurrencyOptVerify.update().
sqlstore.sql.concurrencyoptverify.update=--> ConcurrencyOptVerify.update(), beforeImage = {0}.
sqlstore.sql.generator.dbstatement.addbatch=addbatch ({0})
sqlstore.sql.generator.dbstatement.bindinputcolumn=bindInputColumn index: {0} value: {1} sqlType: {2}.
sqlstore.sql.generator.dbstatement.executebatch=executeBatch executing {0} command(s)
sqlstore.sql.generator.selectqueryplan.processforeignfield.exit=<-- SelectQueryPlan.processForeignFields().
sqlstore.sql.generator.selectqueryplan.processforeignfield=--> SelectQueryPlan.processForeignFields(), class = {0}.
sqlstore.sql.generator.selectqueryplan.processlocalfield.exit=<-- SelectQueryPlan.processLocalFields().
sqlstore.sql.generator.selectqueryplan.processlocalfield=--> SelectQueryPlan.processLocalFields(), class = {0}.
sqlstore.sql.generator.selectqueryplan.processstmts.exit=<-- SelectQueryPlan.processStatements().
sqlstore.sql.generator.selectqueryplan.processstmts=--> SelectQueryPlan.processStatements(), class = {0}, statements = {1}.
sqlstore.sql.updateobjdescimpl.afterimagenull=AfterImage is not set.
sqlstore.sql.updateobjdescimpl.beforeimagenull=BeforeImage is not set.
sqlstore.sql.updateobjdescimpl.markrelationshipchange=<--> UpdateDesc.markRelationshipChange().
sqlstore.sql.updateobjdescimpl.updated={0} is updated.


###############################################################################
# <SQLStoreManager>
# Message ID Range: JDO76400 - JDO76499
###############################################################################
#
# <SQLStoreManager>
#
core.persistencestore.jdbcerror=JDO76400: rilevata una SQLException di JDBC durante l''esecuzione del comando SQL:\n{0}.\nEsaminare la SQLException per ulteriori informazioni.
sqlstore.retrievedesc.stmntsnotjoined=JDO76401: comandi SQL multipli non supportati per una RetrieveDesc.
core.persistencestore.toofewrows=JDO76402: \u00e8 stato restituito un numero di righe inferiore dal database nel tentativo di ottenere il valore dall''associazione {1} della classe {0} rispetto alla cardinalit\u00e0 consentita da questa associazione. Il numero minimo di righe consentito \u00e8 {2}.
core.persistencestore.toomanyobjforcard1=JDO76403: database coerente con il modello persistente. Un tentativo di recuperare l''oggetto referenziato dall''associazione {1} della classe {0} ha recuperato {2} voci, ma pu\u00f2 essere prevista solo 1 voce, poich\u00e9 il limite superiore di cardinalit\u00e0 per l''associazione \u00e8 1.
core.persistencestore.toomanyrows=JDO76405: \u00e8 stato restituito un numero di righe superiore dal database nel tentativo di ottenere il valore per l''associazione {1} della classe {0} rispetto alla cardinalit\u00e0 consentita da questa associazione. Il numero massimo di righe consentito \u00e8 {2}.
core.store.concurrentaccess=JDO76406: eccezione di accesso contemporaneo: l''oggetto relativo a {0} \u00e8 stato aggiornato o eliminato da un''altra transazione.
sqlstore.sqlstoremanager.errorcloseresultset=JDO76407: errore nella chiusura dell''insieme di risultati SQL. Eccezione: {0}
sqlstore.sqlstoremanager.errorclosestatement=JDO76408: errore nella chiusura del comando SQL. Eccezione: {0}
sqlstore.sql.generator.selectqueryplan.plansnotjoined=JDO76409: piani ricerca multipli non supportati per una RetrieveDesc.

#
# <NOI18N: SQLStoreManager>
#
sqlstore.sqlstoremanager.executeQuery.exit=<-- SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeQuery=--> SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeupdate.exit=<-- SQLStoreManager.executeUpdate(), rows affected = {0}.
sqlstore.sqlstoremanager.executeupdate=--> SQLStoreManager.executeUpdate().
sqlstore.sqlstoremanager.executeupdatebatch.addbatch={0}; add batch.
sqlstore.sqlstoremanager.executeupdatebatch.exit=<-- SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.executeupdatebatch.exit.flush=<-- SQLStoreManager.executeUpdateBatch(), rows affected = {0}.
sqlstore.sqlstoremanager.executeupdatebatch.flushbatch={0}; flush batch.
sqlstore.sqlstoremanager.executeupdatebatch=--> SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.getpersistenceconfig=<--> SQLStoreManager.getPersistenceConfig(), classType = {0}.
sqlstore.sqlstoremanager.selectnoncorrelated.exit=<-- SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.selectnoncorrelated=--> SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.vendortype=<--> SQLStoreManager: vendor type = {0}.


###############################################################################
# <Connection/Connectionpool/DBVendorType/TransactionImpl/OracleSpecialDBOperation>
# Message ID Range: JDO76500 - JDO76599
###############################################################################
#
# <Connection/Connection Pool> - database
#
connection.connectionmanager.badnew=JDO76500: il nuovo/a ''{0}'' deve essere maggiore o uguale al/alla ''{1}'' corrente.
connection.connectionmanager.badvalue=JDO76501: valore non valido per ''{0}''.
connection.connectionmanager.conntimeout=JDO76502: timeout di connessione scaduto.
connection.connectionmanager.getconnection.mismatch=JDO76503: la connessione in pool non ha lo stesso contesto utente.
connection.connectionmanager.isdown=JDO76504: la gestione della connessione verr\u00e0 chiusa.
connection.connectionmanager.maxpool=JDO76505: la connessione in pool \u00e8 al massimo.
connection.connectionmanager.msintervalvalue=JDO76506: MsInterval deve essere maggiore di zero e inferiore o uguale a MsWait.
connection.connectionmanager.mswaitvalue=JDO76507: MsWait deve essere maggiore o uguale a zero.
connection.connectionmanager.nulldriver=JDO76508: valore NULL per il nome driver.
connection.connectionmanager.nullurl=JDO76509: valore NULL per l''URL.
connection.connectionmanager.poolsize=JDO76510: 'maxPool' deve essere maggiore o uguale a 'minPool'.
connection.connectionmanager.threaditerupted=JDO76511: thread interrotto.
connection.connectionmanager.zero=JDO76512: ''{0}'' deve essere maggiore o uguale zero.
#
# <DBVendorType>
#
sqlstore.database.dbvendor.cantloadDefaultProperties=JDO76513: impossibile caricare le propriet\u00e0 per il database predefinito.
sqlstore.database.dbvendor.init.default=JDO76514: -->Impossibile caricare la propriet\u00e0 per il tipo di distributore {0}. Verranno utilizzati i valori predefiniti.
sqlstore.database.dbvendor.cantinstantiateclass=JDO76515: impossibile istanziare la classe {0}.
#
# <OracleSpecialDBOperation>
#
sqlstore.database.oracle.defineCol=JDO76516: impossibile definire la colonna per l''istruzione.
sqlstore.database.oracle.nooracleavailable=JDO76517: impossibile ottenere un''istanza di oracle.jdbc.OraclePreparedStatement o oracle.jdbc.driver.OraclePreparedStatement durante l''inizializzazione della factory delle risorse di Oracle ''{0}''. L''ottimizzazione specifica per Oracle verr\u00e0 disabilitata. Se le istanze che usano questa risorsa richiedono valori di associazione per le colonne mappate alla colonna Fixed Char, verr\u00e0 eseguita la spaziatura dei valori fino a raggiungere la lunghezza specificata nel file dbschema corrispondente.
sqlstore.database.oracle.fixedcharpadded=JDO76518: il valore "{0}" \u00e8 associato a una colonna CHAR. Ci\u00f2 richiede una gestione speciale in Oracle. Poich\u00e9 \u00e8 impossibile ottenere la classe OraclePreparedStatement dal driver, viene eseguita la spaziatura del valore {1} come specificato nel file dbschema catturato.
#
# <Misc.>
#
core.configuration.getvendortypefailed=JDO76519: impossibile identificare il tipo di distributore per il data store.
jdo.sqlpersistencemanagerfactory.errorgettingDatabaseInfo=JDO76520: errore durante l''ottenimento di informazioni sul database. Rilevata l''eccezione seguente:

#
# <NOI18N: Connection>
#
sqlstore.connection.conncectiomgr.found=<--> ConnectionManager.getConnection: found {0}.
sqlstore.connection.conncectiomgr.getnewconn=<--> ConnectionManager.getConnection: new {0}.
sqlstore.connection.conncectiomgr.replacefreeconn=<--> ConnectionManager.replaceFreeConnection: free {0}.
sqlstore.connectionimpl.clearxact.close=--- ConnectionImpl.clearXact: connection closed .
sqlstore.connectionimpl.clearxact.disassocxact=--- ConnectionImpl.clearXact: disassociateXact .
sqlstore.connectionimpl.clearxact=--- ConnectionImpl.clearXact: .
sqlstore.connectionimpl.close.connrelease=<--- ConnectionImpl.close: connection released.
sqlstore.connectionimpl.close.exit=<--- ConnectionImpl.close: connection closed.
sqlstore.connectionimpl.close.freepending=<--- ConnectionImpl.close: set FreePending.
sqlstore.connectionimpl.close.putfreelist=<--- ConnectionImpl.close: put in freeList.
sqlstore.connectionimpl.close.replaced=<--- ConnectionImpl.close: connection replaced.
sqlstore.connectionimpl.close=---> ConnectionImpl.close.
sqlstore.connectionimpl.close_arg=---> ConnectionImpl.close: {0}.
sqlstore.connectionimpl.commit=--- ConnectionImpl.commit: connection closed.
sqlstore.connectionimpl.finalize=--- ConnectionImpl.finalize: connection closed.
sqlstore.connectionimpl.internalcommit=--- ConnectionImpl.internalCommit: .
sqlstore.connectionimpl.pendingdisassocxact=--- ConnectionImpl.clearXact: Pending disassociateXact.
sqlstore.connectionimpl.rollback.close=--- ConnectionImpl.rollback: connection closed.
sqlstore.connectionimpl.rollback=--- ConnectionImpl.rollback:.
#
# <NOI18N: DBVendorType>
#
sqlstore.database.dbvendor.castRequiredForNumericValues=<-> DBVendorType.isCastRequiredForNumericValues(): {0}.
sqlstore.database.dbvendor.getModFunctionName=<-> DBVendorType.getModFunctionName(): {0}.
sqlstore.database.dbvendor.getNullComparisonFunctionName=<-> DBVendorType.getNullComparisonFunctionName(): {0}.
sqlstore.database.dbvendor.getConcatCast=<-> DBVendorType.getConcatCast(): {0}.
sqlstore.database.dbvendor.getSpecialDBOperation=<-> DBVendorType.getSpecialDBOperation(): {0}.
sqlstore.database.dbvendor.getabs=<-> DBVendorType.getAbs(): {0}.
sqlstore.database.dbvendor.getcharlength=<-> DBVendorType.getCharLength(): {0}.
sqlstore.database.dbvendor.getforupdate=<-> DBVendorType.getForUpdate(): {0}.
sqlstore.database.dbvendor.getholdlock=<-> DBVendorType.getHoldlock(): {0}.
sqlstore.database.dbvendor.getisnotnull=<-> DBVendorType.getIsNotNull(): {0}.
sqlstore.database.dbvendor.getisnull=<-> DBVendorType.getIsNull(): {0}.
sqlstore.database.dbvendor.getleftjoin=<-> DBVendorType.getLeftJoin(): {0}.
sqlstore.database.dbvendor.getleftjoinpost=<-> DBVendorType.getLeftJoinPost(): {0}.
sqlstore.database.dbvendor.getleftlikeescape=<-> DBVendorType.getLeftLikeEscape(): {0}.
sqlstore.database.dbvendor.getnotequal=<-> DBVendorType.getNotEqual(): {0}.
sqlstore.database.dbvendor.getposition3args=<-> DBVendorType.getPositionThreeArrgs(): {0}.
sqlstore.database.dbvendor.getposition=<-> DBVendorType.getPosition(): {0}.
sqlstore.database.dbvendor.getpositionin=<-> DBVendorType.getPositionIn(): {0}.
sqlstore.database.dbvendor.getpositionsrchsrc=<-> DBVendorType.getPositionSearchSource(): {0}.
sqlstore.database.dbvendor.getquotecharstart=<-> DBVendorType.getQuoteCharStart(): {0}.
sqlstore.database.dbvendor.getrightjoinipre=<-> DBVendorType.getRightJoin(): {0}.
sqlstore.database.dbvendor.getrightlikeescape=<-> DBVendorType.getRightLikeEscape(): {0}.
sqlstore.database.dbvendor.getrtrim=<-> DBVendorType.getRtrim(): {0}.
sqlstore.database.dbvendor.getrtrimpost=<-> DBVendorType.getRtrimPost(): {0}.
sqlstore.database.dbvendor.getsqrt=<-> DBVendorType.getSqrt(): {0}.
sqlstore.database.dbvendor.getstringconcat=<-> DBVendorType.getStringConcat(): {0}.
sqlstore.database.dbvendor.getsubstring=<-> DBVendorType.getSubstring(): {0}.
sqlstore.database.dbvendor.getsubstringfor=<-> DBVendorType.getSubstringFor(): {0}.
sqlstore.database.dbvendor.getsubstringfrom=<-> DBVendorType.getSubstringFrom(): {0}.
sqlstore.database.dbvendor.gettablelistend=<-> DBVendorType.getTableListEnd(): {0}.
sqlstore.database.dbvendor.gettableliststart=<-> DBVendorType.getTableListStart(): {0}.
sqlstore.database.dbvendor.isAnsiTrim=<-> DBVendorType.isAnsiTrim(): {0}.
sqlstore.database.dbvendor.isInlineNumeric=<-> DBVendorType.isInlineNumeric(): {0}.
sqlstore.database.dbvendor.isNativeOuterJoin=<-> DBVendorType.isNativeOuterJoin(): {0}.
sqlstore.database.dbvendor.isParameterCast=<-> DBVendorType.isParameterCast(): {0}.
sqlstore.database.dbvendor.isdistinctupdatelocksupported=<-> DBVendorType.isDistinctSupportedWithUpdateLock(): {0}.
sqlstore.database.dbvendor.islockcolumnlistsupported=<-> DBVendorType.isLockColumnListSupported(): {0}.
sqlstore.database.dbvendor.isupdatelocksupported=<-> DBVendorType.isUpdateLockSupported(): {0}.
sqlstore.database.dbvendor.mapemptystrtonull=<-> DBVendorType.mapEmptyStringToNull(): {0}.
sqlstore.database.dbvendor.overrideproperties.with=<-> DBVendorType.overrideProperties() : {0} with: {1}.
sqlstore.database.dbvendor.overrideproperties=<-> DBVendorType.overrideProperties() - NONE.
sqlstore.database.dbvendor.supportslikeescape=<-> DBVendorType.supportsLikeEscape(): {0}.
sqlstore.database.dbvendor.vendorname=<-> DBVendorType(), vendorName: [{0}]  vendorType: {1}.
#
# <NOI18N: TransactionImpl>
#
sqlstore.transactionimpl.call.info={0} Tran[ {1} ].{2}: {3} for  {4}.
sqlstore.transactionimpl.call={0} Tran[ {1} ].{2}:status = {3}, txType: {4} for  {5}.
sqlstore.transactionimpl.closeconnection=--- TransactionImpl.closeConnection() {0} for {1}.
sqlstore.transactionimpl.general={0}.
sqlstore.transactionimpl.getconnection=--- TransactionImpl.getConnection(): {0} TX optimistic: {1} referenceCount = {2} for {3}.
sqlstore.transactionimpl.releaseconnection=--- TransactionImpl.releaseConnection(): TX optimistic: {0} Inside Commit: {1} referenceCount: {2} for {3}.
sqlstore.transactionimpl.rollbackconnection=--- TransactionImpl.rollbackConnection(): {0} for {1}.
sqlstore.transactionimpl.status={0} Tran[ {1} ].setStatus: {2} => {3} for {4}.


###############################################################################
# All the source files under subdir ejb.
# Message ID Range: JDO76600 - JDO76699
###############################################################################
#
#EJBHelper messages
#
# {0} - method name
ejb.ejbhelper.nonmanaged=JDO76600: il metodo {0} non deve essere invocato in un ambiente non gestito.

#
# Common messages between SunContainerHelper and DeploymentHelper
# so they have a neutral key, that still starts with "ejb".
#
# {0} - jndi name.
ejb.jndi.lookupfailed=JDO76604: ricerca JNDI della risorsa CMP ''{0}'' non riuscita.
JDO76604.diag.cause.1=La risorsa CMP con questo nome JNDI non \u00e8 registrata con questa istanza.
JDO76604.diag.cause.1=Il nome JNDI per la risorsa CMP non \u00e8 corretto.
JDO76604.diag.check.1=Controllare il nome JNDI per la risorsa che si intende usare.
JDO76604.diag.check.2=Controllare il nome JNDI della risorsa CMP specificata nel modulo.

# {0} - jndi name.
# {1} - returned class name.
ejb.jndi.unexpectedinstance=JDO76605: la ricerca JNDI della risorsa CMP ''{0}'' ha restituito un''istanza di tipo imprevisto: {1}.
JDO76605.diag.cause.1=La risorsa CMP con questo nome JNDI non fa riferimento alla risorsa JDBC o alla risorsa persistence-manager-factory.
JDO76604.diag.cause.1=Il nome JNDI per la risorsa CMP non \u00e8 corretto.
JDO76604.diag.check.1=Controllare il nome JNDI per la risorsa che si intende usare.
JDO76604.diag.check.2=Controllare il nome JNDI della risorsa CMP specificata nel modulo.

#
# DeploymentHelper messages - ejb
#
#
#<NOI18N: DeploymentHelper>
#
ejb.DeploymentHelper.getconnection=Getting connection for JNDI name ''{0}''.

# The messages JDO76606 through JDO76615 that were originally here 
# have been moved to 
# cmp/support/ejb/src/com/sun/jdo/spi/persistence/support/ejb/ejbc/Bundle.properties
# As part of INF#
# So do not use these messages. 


#
#CMPHelper messages
#
ejb.cmphelper.nonmanaged=JDO76613: accesso non valido di CMPHelper. Questa classe \u00e8 utilizzata solo per il supporto CMP e non deve essere invocata fuori da un server di applicazioni.

#
#SunTransactionHelper messages
#

# {0} class name
ejb.SunTransactionHelper.wrongdatasourcetype=JDO76616: DataSource non del tipo previsto. Previsto: com.sun.appserv.jdbc.DataSource got: {0}.


###############################################################################
# <Generic messages. Add new messages to this section only if none of the above categories can be used.>
###############################################################################
#
# <NOI18N: generic>
#
vendor=Sun Microsystems
# majorVersion (minorVersion) buildDate
fullVersion={0} ({1}) {2}
#
# <NOI18N: This messages are used for JDOFatalInternalException from multiple places. No need to I18N>
#
core.generic.unknownfield=The field {0} is not a member of the class {1}.
core.generic.unknownexception=Got an unknown exception.
core.generic.nullparam=The {0} parameter is null.
core.generic.notinstanceof=The object of class {0} is not an instance of {1}.


###############################################################################
# <These messages are used from multiple places in code.It is absolutely necessary to cleanup code
# to use different messages >
###############################################################################
core.configuration.cantloadclass=Impossibile caricare la classe {0}.
sqlstore.exception.log=Eccezione.
jdo.lifecycle.deleted.accessField=Impossibile accedere a un campo di un''istanza eliminata.
