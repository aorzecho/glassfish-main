#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 1997-2010 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

# Resource bundle for sqlstore runtime messages
# key consists of: <subpackage>.<class>.<method>.<description>
# <subpackage> - is optional, package under runtime
# <class> - class name
# <method> - method name
# <description> - short description (use _ to represent space)
# all keys should be in lowercase
#
# Please note that many package names and classnames have changed over time.
# Unfortunately, this file was not maintained to follow above convention.
# Please ignore if the package/class name does not match actual names as today.
#
#
# The message ID for a message in persistence is derived as follows:
# JDO<2_digit_bundle_prefix><1_digit_section_number><2_digit_serial_number>
#
# The 2 digit prefix for this bundle is 76.
#
# This file is divided into the following sections:
# Under each section, messages that need not be I18Ned are separated under NOI18N. All other messages
# need to be numbered.
# 1. JDO:  PersistenceManagerFactory/PersistenceManager/ExtentCollection/LifeCycle
# 2. Model
# 3. StateManager
# 4. sql generator components: RetrieveDesc, ResultDesc plus all the files under generator subdir
# 5. SQLStoreManager
# 6. Connection/Connectionpool/Transaction/DBVendorType
# 7. EJB integration.
# 8. Generic messages.
#
# When adding a new message:
# 1. Please make sure that you add the message to the end of appropriate section.
# 2. Please add message ID to any user visible message.
# 3. The message ID for the new message = message ID for the last numbered
#    message in a section + 1.
# 4. Please do not change the message ID for existing messages. These
#    numbers are potentially mapped to more explanation about the message for
#    the end user.
#

####################################################################################################
# <All the source files under subdir impl (PersistenceManagerFactory/PersistenceManager etc.) >
# Message ID Range: JDO76000 - JDO76099
####################################################################################################
jdo.persistencemanagerfactoryimpl.getpersistencemanager.error=JDO76000: N\u00e3o \u00e9 poss\u00edvel utilizar m\u00faltiplas combina\u00e7\u00f5es de nome de usu\u00e1rio/senha na mesma transa\u00e7\u00e3o.
jdo.persistencemanagerfactoryimpl.getpersistencemanager.notconfigured=JDO76001: O PersistenceManagerFactory n\u00e3o est\u00e1 configurado.
jdo.persistencemanagerfactoryimpl.notsupported=JDO76002: A opera\u00e7\u00e3o n\u00e3o possui suporte para o PersistenceManagerFactoryImpl interno.
jdo.persistencemanagerimpl.acquireexclusivelock.interrupted=JDO76003: Falha ao adquirir o bloqueio exclusivo devido a InterruptedException
jdo.persistencemanagerimpl.acquiresharelock.failed=JDO76004: Falha ao adquirir o bloqueio compartilhado porque _readWriteCount \u00e9 menor do que zero.
jdo.persistencemanagerimpl.acquiresharelock.interrupted=JDO76005: Falha ao adquirir o bloqueio compartilhado devido a InterruptedException
jdo.persistencemanagerimpl.another_pm=JDO76006: O objeto est\u00e1 associado com outro PersistenceManager.
jdo.persistencemanagerimpl.assertactivetransaction.error=JDO76007: A transa\u00e7\u00e3o associada com esse gerenciador de persist\u00eancia n\u00e3o est\u00e1 ativa.
jdo.persistencemanagerimpl.assertclosed.closed=JDO76008: O PersistenceManager est\u00e1 fechado.
jdo.persistencemanagerimpl.assertpersistencecapable.error=JDO76009: A classe {0} n\u00e3o foi aprimorada para a persist\u00eancia transparente. Utilize o JAR do IDE ou o empacotador WAR para empacotar suas classes com capacidade de persist\u00eancia antes de executar. Ou, defina a propriedade Executor na classe principal como Executor da persist\u00eancia a ser executado a partir do IDE.
jdo.persistencemanagerimpl.close.activetransaction=JDO76010: H\u00e1 uma transa\u00e7\u00e3o aberta associada com esse gerenciador de persist\u00eancia.
jdo.persistencemanagerimpl.fetchinstance.none=JDO76012: O objeto n\u00e3o \u00e9 encontrado para este ObjectId.
jdo.persistencemanagerimpl.internaldeletepersistent.transient=JDO76014: N\u00e3o \u00e9 poss\u00edvel excluir um objeto n\u00e3o-persistente.
jdo.persistencemanagerimpl.internalmakepersistent.dups=JDO76015: Uma inst\u00e2ncia com a mesma chave principal j\u00e1 existe no cache PersistenceManager.
jdo.persistencemanagerimpl.loadclassforoid.wrongoidclass=JDO76016: Erro ao recuperar a classe do objeto do OID.
jdo.persistencemanagerimpl.newscoinstance.wrongclass=JDO76017: N\u00e3o \u00e9 poss\u00edvel criar a inst\u00e2ncia SCO da classe {0} por n\u00e3o ser de um tipo v\u00e1lido.
jdo.persistencemanagerimpl.notprocessed=JDO76018: N\u00e3o \u00e9 poss\u00edvel limpar inst\u00e2ncias de persist\u00eancia devido a depend\u00eancias circulares.
jdo.persistencemanagerimpl.releaseexclusivelock.failed=JDO76019: Falha ao liberar o bloqueio compartilhado porque _readWriteCount \u00e9 maior do que zero.
jdo.persistencemanagerimpl.releasesharelock.failed=JDO76020: Falha ao liberar o bloqueio compartilhado porque _readWriteCount \u00e9 zero.
jdo.persistencemanagerwrapper.invalidpm=JDO76021: O PersistenceManagerWrapper est\u00e1 fechado.
jdo.extentcollection.constructor.invalidclass=JDO76022: Classe inv\u00e1lida ''{0}'' para a cole\u00e7\u00e3o de extens\u00e3o.
jdo.extentcollection.constructor.nonpc=JDO76023: A classe ''{0}'' n\u00e3o \u00e9 de capacidade de persit\u00eancia.
jdo.extentcollection.constructor.subclasses=JDO76024: As subclasses de op\u00e7\u00e3o verdadeiras n\u00e3o possuem suporte para cole\u00e7\u00f5es de extens\u00f5es.
jdo.extentcollection.illegalmodification=JDO76025: Modifica\u00e7\u00e3o ilegal da cole\u00e7\u00e3o de extens\u00e3o para a classe ''{0}''.
jdo.extentcollection.methodnotsupported=JDO76026: O m\u00e9todo {0} de cole\u00e7\u00e3o de extens\u00e3o n\u00e3o possui suporte.
jdo.lifecycle.xactnotactive=JDO76027: A transa\u00e7\u00e3o ativa necess\u00e1ria para executar esta opera\u00e7\u00e3o.
jdo.persistencemanagerimpl.newinstance.badsm=JDO76028: O StateManager n\u00e3o est\u00e1 totalmente configurado!
jdo.persistencemanagerimpl.setjtatransaction.notnulljta=JDO76029: Tentativa de substituir javax.transaction.Transaction n\u00e3o-nula: {0} por {1}.
jdo.persistencemanagerfactoryimpl.getpersistencemgr.closed=JDO76030: O PersistenceManager para essa javax.transaction.Transaction: {0} j\u00e1 est\u00e1 fechado ou comprometendo.
jdo.persistencemanagerfactoryimpl.registerpm.registered=JDO76031: Esta inst\u00e2ncia do javax.transaction.Transaction: {0} j\u00e1 est\u00e1 registrada com outro PersistenceManager: {1}.
jdo.persistencemanagerimpl.verificationfailed=JDO76032: Falha da verifica\u00e7\u00e3o com o armazenador de dados pela inst\u00e2ncia de consist\u00eancia da vers\u00e3o.
jdo.persistencemanagerfactoryimpl.getversionconsistencycache.nullstore=JDO76033: O StoreManager n\u00e3o est\u00e1 configurado.

#
# <NOI18N: LifeCycle>
#
sqlstore.state.lifecyclestate.changestate=LifeCycleState.changeState(), old state = {0}, new state = {1}.
sqlstore.state.lifecyclestate.initial=LifeCycleState.getLifeCycleState(), initial state = {0}.

#
# <NOI18N: PersistenceManager>
#
sqlstore.persistencemgr.acquireexclusivelock.count=acquireExclusiveLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.acquireexclusivelock=acquireExclusiveock(), thread {0} going to wait.
sqlstore.persistencemgr.acquiresharedlock.rdwrcount=acquireShareLock(), thread {0} acquired shared lock with _readWriteCount ={1}.
sqlstore.persistencemgr.acquiresharedlock=acquireShareLock(), thread {0} going to wait.
sqlstore.persistencemgr.aftercompletion.process=---PersistenceManagerImpl.afterCompletion() process: {0}.
sqlstore.persistencemgr.aftercompletion=---PersistenceManagerImpl.afterCompletion() abort: {0}.
sqlstore.persistencemgr.assertactivetx.closed=--- PersistenceManagerImpl.assertActiveTransaction: Closed for  {0}.
sqlstore.persistencemgr.assertactivetx=--- PersistenceManagerImpl.assertActiveTransaction:  {0}.
sqlstore.persistencemgr.assertisopen=--- PersistenceManagerImpl.assertIsOpen: CLOSED for {0}.
sqlstore.persistencemgr.beforecompletion=---PersistenceManagerImpl.beforeCompletion().
sqlstore.persistencemgr.cacheproperties=PersistenceManagerImpl cache properties: _txCacheInitialCapacity={0}, _flushedCacheInitialCapacity={1}, _flushedCacheLoadFactor={2}, _weakCacheInitialCapacity={3}, _weakCacheLoadFactor={4}.
sqlstore.persistencemgr.deregisterinstance.verified=---PersistenceManagerImpl.deregisterInstance() -- deregistered with verify.
sqlstore.persistencemgr.deregisterinstance.verify=---PersistenceManagerImpl.deregisterInstance() with verify SM -- oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.deregisterinstance=---PersistenceManagerImpl.deregisterInstance() oid: {0}  for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getbyobjid=---PersistenceManagerImpl.getObjectById() OID:{0}  for PersistenceManager: {1} and JTA: {2}.
sqlstore.persistencemgr.getcurrentwrapper=---PersistenceManagerImpl.getCurrentWrapper() > current: {0}.
sqlstore.persistencemgr.getobjid.notpc=---PersistenceManagerImpl.getObjectId() NOT PC: {0}  for PersistenceManager: {1}.
sqlstore.persistencemgr.getobjid.notpm=---PersistenceManagerImpl.getObjectId() NOT PM: {0} for PersistenceManager: {1}  and JTA: {2}.
sqlstore.persistencemgr.getobjid= :{0} ---PersistenceManagerImpl.getObjectId() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.internalcloneoid.old=---PersistenceManagerImpl.internalCloneOid(): old: {0}  new: {1} same: {2}.
sqlstore.persistencemgr.internalcloneoid=---PersistenceManagerImpl.internalCloneOid() ERROR: {0}.
sqlstore.persistencemgr.isactivetx=---PersistenceManagerImpl.isActiveTransaction() : {0}.
sqlstore.persistencemgr.isnontxread=---PersistenceManagerImpl.isNontransactionalRead() : {0}.
sqlstore.persistencemgr.isoptimistic=---PersistenceManagerImpl.isOptimisticTransaction() : {0}.
sqlstore.persistencemgr.loadingclass=Loading ... ClassName: {0}.
sqlstore.persistencemgr.loadingfile=Loading ... FileName: {0} {1} {2}.
sqlstore.persistencemgr.makepersistent.done=---PersistenceManagerImpl.makePersistent() {0}  finished for: {1}  and JTA: {2}.
sqlstore.persistencemgr.makepersistent= {0} ---PersistenceManagerImpl.makePersistent() PC: {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.newcollection=---PersistenceManagerImpl.newCollectionInstanceInternal() type: {0}.
sqlstore.persistencemgr.popcurrentwrapper=---PersistenceManagerImpl.popCurrentWrapper() > current: {0}  prev: {1}.
sqlstore.persistencemgr.pushcurrentwrapper=---PersistenceManagerImpl.pushCurrentWrapper() > current: {0}  new: {1}.
sqlstore.persistencemgr.registerinstance= {0} ---PersistenceManagerImpl.registerInstance() oid/sm: {1}/{2}  for PersistenceManager: {3}  and JTA: {4}.
sqlstore.persistencemgr.registerinstancein_txc=registerInstance in TXC :{0} / {1} for PersistenceManager: {2} and JTA: {3}.
sqlstore.persistencemgr.registerinstancein_wkc=registerInstance in WKC.
sqlstore.persistencemgr.releaseexclusivelock=releaseExclusiveock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.releasesharedlock=releaseShareLock(), thread {0} with _readWriteCount = {1}.
sqlstore.persistencemgr.replacingdeletedinstance=Replacing deleted instance with new for Object Id: {0}.
sqlstore.persistencemgr.setkeyfields=---PersistenceManagerImpl.setKeyFields() ERROR: {0}.
#
# <NOI18N: PersistenceManagerFactory>
#
sqlstore.sqlpersistencemgrfactory.getfrompool.pmt=<--SQLPersistenceManagerFactory.getFromPool() PM: {0} for JTA {1}.
sqlstore.sqlpersistencemgrfactory.getfrompool=<--SQLPersistenceManagerFactory.getFromPool().
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.found= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() FOUND javax.transaction.Transaction: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx.notfound=<->SQLPersistenceManagerFactory.getPersistenceManager() NOT FOUND JDO Transaction:.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.jdotx=<->SQLPersistenceManagerFactory.getPersistenceManager() JDO Transaction: {0}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmclosedfor= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() PM is CLOSED FOR: {1}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr.pmt= {0} <->SQLPersistenceManagerFactory.getPersistenceManager() : {1} for JTA: {2}.
sqlstore.sqlpersistencemgrfactory.getpersistencemgr=:{0} -->SQLPersistenceManagerFactory.getPersistenceManager().
sqlstore.sqlpersistencemgrfactory.init=---SQLPersistenceManagerFactory.initialize().
sqlstore.sqlpersistencemgrfactory.pmCacheBucketSize=---SQLPersistenceManagerFactory pmCacheBucketSize = {0}.
sqlstore.sqlpersistencemgrfactory.pmCacheInitialCapacity=---SQLPersistenceManagerFactory pmCacheInitialCapacity = {0}.
sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt=<->SQLPersistenceManagerFactory.registerPersistenceManager() PM: {0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.releasepm.pmt=---SQLPersistenceManagerFactory.releasePersistenceManager() PM:{0} for JTA Tx: {1}.
sqlstore.sqlpersistencemgrfactory.returnToPool=<--SQLPersistenceManagerFactory.returnToPool().


###############################################################################
# <Model>
# Message ID Range: JDO76100 - JDO76199
###############################################################################
core.configuration.columnnotable=JDO76100: O descritor da coluna n\u00e3o tinha um descritor de tabela v\u00e1lido.
core.configuration.fieldnotable=JDO76101: O campo {1} n\u00e3o est\u00e1 associado com nenhuma tabela.
core.configuration.fieldnotmapped=JDO76102: O campo de persist\u00eancia {0} para a classe {1} n\u00e3o est\u00e1 mapeado.
core.configuration.iddescnofield=JDO76103: O objeto SqlIDDesc n\u00e3o foi corretamente configurado.  N\u00e3o h\u00e1 descritores de campo dispon\u00edveis.
core.configuration.loadfailed.class=JDO76104: Falha ao carregar a configura\u00e7\u00e3o para a classe {0}.
core.configuration.noneexistentpkfield=JDO76105: O campo {0} na classe ObjectId {1} n\u00e3o existe na classe PersistenceCapable {2}.
core.configuration.unsupportedconsistencylevel=JDO76106: A classe {0} tem um n\u00edvel de consist\u00eancia n\u00e3o suportado. Os n\u00edveis de consist\u00eancia no momento suportados s\u00e3o "nenhum", "verificar modificado ao comprometer", "bloquear quando carregado" e "verificar vers\u00e3o de inst\u00e2ncias acessadas".
core.configuration.validationfailed=JDO76107: O mapeamento para a classe {0} \u00e9 inv\u00e1lido:\n{1}.
core.configuration.validationproblem=JDO76108: Erro de valida\u00e7\u00e3o na classe {0}: {1}
#
# <FieldDesc validation at runtime>
#
core.fielddesc.minvalue=JDO76109: Valor: {0} \u00e9 menor do que o m\u00ednimo permitido: {1} para o tipo de campo {2}.
core.fielddesc.maxvalue=JDO76110: Valor: {0} \u00e9 maior do que o m\u00e1ximo permitido: {1} para o tipo de campo {2}.
core.configuration.noneexistentvcfield=JDO76111: O campo {0} est\u00e1 marcado como campo de vers\u00e3o, mas n\u00e3o existe na classe PersistenceCapable {1}.
core.configuration.loadfailed.field=JDO76112: Falha ao carregar a configura\u00e7\u00e3o para o campo {0} na classe {1}.

#
# <NOI18N: model>
#
sqlstore.model.classdesc.assocrelatedfield=associated relationship field = {0}.
sqlstore.model.classdesc.createsqldesc=creating SqlIDDesc from {0}.
sqlstore.model.classdesc.fieldinfo=field name = {0}, id= {1}.
sqlstore.model.classdesc.general={0}.{1} =>{2}
sqlstore.model.classdesc.getlocalfielddesc=<-> SqlPersistenceDesc.getLocalFieldDesc(), class ={0} added hidden field {1}  for column {2}.
sqlstore.model.classdesc.loadedclass=Successfully loaded oid class= {0}.
sqlstore.model.classdesc.persistconfiginit.exit=<-- SqlPersistenceConfig.initialize().
sqlstore.model.classdesc.persistconfiginit=--> SqlPersistenceConfig.initialize(), class = {0}.
sqlstore.model.classdesc.pkfield=PK field = {0}.
sqlstore.model.classdesc.primarytrackedfield=field {0} is the primary tracked field .
sqlstore.model.classdesc.unsetconcurrencychk=unsetting IN_CONCURRENCY_CHECK property for lf  {0}.
sqlstore.model.classdesc.unsetrefintegrityupdate=unsetting REF_INTEGRITY_UPDATES property for ff {0}.
sqlstore.model.classdesc.vcfield=Version consistency field = {0}.
sqlstore.model.fielddesc.addingfield=adding field {0} to be tracked by field {1}.
sqlstore.model.fielddesc.convertvalue.from_to=convertValue: {0} From: {1} To: {2}.
sqlstore.model.fielddesc.convertvalue.hidden=convertValue: hidden {0} ... return.
sqlstore.model.fielddesc.convertvalue=convertValue: NULL ... return.
sqlstore.model.fielddesc.fieldname={0} = {1}.
sqlstore.model.fielddesc.setupdesc=setupDesc(): fieldName {0} fieldType {1}.
sqlstore.model.configcacheimpl.size_before={0} size before cleanup: {1}.
sqlstore.model.configcacheimpl.size_after={0} size after cleanup: {1}.


###############################################################################
# <StateManager>
# Message ID Range: JDO76200 - JDO76299
###############################################################################
core.statemanager.anotherowner=JDO76200: N\u00e3o \u00e9 poss\u00edvel atribuir a inst\u00e2ncia SCO que \u00e9 de propriedade de outro objeto.
core.statemanager.cantnewoid=JDO76201: Falha em criar uma nova inst\u00e2ncia de chave principal da classe {0}.
core.statemanager.cantschedulejointable=JDO76202: Falha em agendar a entrada de tabela unida entre a classe {0} e {1} porque a descri\u00e7\u00e3o do campo de relacionamento \u00e9 nula.
core.statemanager.cantsetkeyfield=JDO76203: Falha ao definir o valor para o campo de chave principal {0}.
core.statemanager.conflictingvalues=JDO76204: Valores conflitantes entre o campo {0} e o campo {1} que est\u00e3o mapeados para a mesma coluna.
core.statemanager.getfieldfailed=JDO76205: Falha ao obter o campo.
core.statemanager.invalidpk=JDO76206: Campo de chave principal nula inv\u00e1lido {0} ao recarregar uma inst\u00e2ncia de classe com capacidade de persist\u00eancia {1}. O ObjectId da inst\u00e2ncia \u00e9 {2}.
core.statemanager.nopkupdate=JDO76207: A atualiza\u00e7\u00e3o do campo da chave principal n\u00e3o \u00e9 permitida.
core.statemanager.nopm=JDO76208: O gerenciador de estado n\u00e3o cont\u00e9m uma refer\u00eancia para o gerenciador de persist\u00eancia.
core.statemanager.notnavigable=JDO76209: Foi feita uma tentativa de acessar o campo {0} da classe {1}.  Esse campo n\u00e3o foi anteriormente instanciado e essa classe n\u00e3o permite a navega\u00e7\u00e3o din\u00e2mica.  \u00c9 preciso solicitar o campo ao recuperar a classe ou permitir a navega\u00e7\u00e3o din\u00e2mica para que ele possa ser automaticamente recuperado quando acessado.
core.statemanager.objectnotfound=JDO76210: O objeto n\u00e3o existe no armazenador de dados.
core.statemanager.poshiddenindex=JDO76211: O \u00edndice para um campo oculto deveria ser negativo, mas foi obtido um \u00edndice de {0}.
core.statemanager.readonly=JDO76212: Foi feita uma tentativa de modificar um campo de somente leitura {0} da classe {1}.
core.statemanager.releaselock.wrongthread=JDO76213: Este segmento {0} n\u00e3o armazena o bloqueio do StateManager.
core.statemanager.setfieldfailed=JDO76214: Falha ao definir o campo.
core.statemanager.wrongusageforoverlappingpkfkdelete=JDO76215: Tentativa incorreta de remover uma inst\u00e2ncia de um relacionamento gerenciado. O relacionamento \u00e9 definido por uma coluna de chave principal no outro lado. Uma opera\u00e7\u00e3o de remo\u00e7\u00e3o em uma cole\u00e7\u00e3o requer a atualiza\u00e7\u00e3o da coluna no outro lado e, a atualiza\u00e7\u00e3o da chave principal n\u00e3o \u00e9 permitida. Portanto, a remo\u00e7\u00e3o de uma inst\u00e2ncia de uma cole\u00e7\u00e3o de relacionamento gerenciado definida por uma chave principal pode ser feita somente ao excluir a inst\u00e2ncia, explicitamente ou por exclus\u00e3o em cascata.
core.statemanager.toomanyrows=JDO76215: Mais de uma linha foi retornada para uma das tabelas mapeadas a classe {0}.  Cada tabela mapeada a uma classe deveria ter somente uma linha para cada inst\u00e2ncia do objeto.
core.statemanager.copyFields.mismatch=JDO76216: Tentativa de copiar campos de um StateManager para outro, que est\u00e3o gerenciando inst\u00e2ncias de diferentes tipos: {0} e {1}.

#
# <NOI18N: StateManager>
#
sqlstore.sqlstatemanager.adddependency=<-> SQLStateManager.addDependency(), this StateManager: {0}, other StateManager: {1}.
sqlstore.sqlstatemanager.addupdate=<-> SQLStateManager.addUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.applyupdates.exit=<-- SqlStateManager.applyUpdates().
sqlstore.sqlstatemanager.applyupdates=--> SqlStateManager.applyUpdates(), field = {0}.
sqlstore.sqlstatemanager.clearpersistencefields.exit=<--- SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.clearpersistencefields=--> SqlStateManager.clearPersistenceFields().
sqlstore.sqlstatemanager.copychanges.exit=<-- SQLStateManager.copyChanges().
sqlstore.sqlstatemanager.copychanges=--> SQLStateManager.copyChanges(), state manager = {0}.
sqlstore.sqlstatemanager.deletepersistence=<-> SqlStateManager.deletePersistence(), type = {0}.
sqlstore.sqlstatemanager.getbeforeimage.exit=<-- SqlStateManager.getBeforeImage().
sqlstore.sqlstatemanager.getbeforeimage=--> SqlStateManager.getBeforeImage(), type = {0}.
sqlstore.sqlstatemanager.isbeforeimagerequired=isBeforeImageRequired is : {0}.
sqlstore.sqlstatemanager.loadforread.exit=<-- SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforread=--> SQLStateManager.loadForRead().
sqlstore.sqlstatemanager.loadforupdate.exit=<-- SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loadforupdate=--> SQLStateManager.loadForUpdate().
sqlstore.sqlstatemanager.loggingfield=logging field = {0} with value = {1}.
sqlstore.sqlstatemanager.makedirty.fixscocollection=--- SqlStateManager.makeDirty(), fix SCOCollection.
sqlstore.sqlstatemanager.makedirty.fixscodate=--- SqlStateManager.makeDirty(), fix SCODate.
sqlstore.sqlstatemanager.makedirty=--> SqlStateManager.makeDirty(), field = {0}.
sqlstore.sqlstatemanager.makedirtyfield=marked dirty field = {0}.
sqlstore.sqlstatemanager.makepersistence=<-> SqlStateManager.makePersistence(), type = {0}.
sqlstore.sqlstatemanager.makepresent=--> SqlStateManager.makePresent(), field = {0}.
sqlstore.sqlstatemanager.marking=marking: {0} as present.
sqlstore.sqlstatemanager.newtype=New Type: {0}.
sqlstore.sqlstatemanager.nosuchmethodexcep.clone=Exception : {0}  clone ... for type {1}.
sqlstore.sqlstatemanager.preparegetfield.exit=<-- SqlStateManager.prepareGetField().
sqlstore.sqlstatemanager.preparegetfield=--> SqlStateManager.prepareGetField(), name = {0}.
sqlstore.sqlstatemanager.preparesetfield.exit=<-- SQLStateManager.prepareSetField().
sqlstore.sqlstatemanager.preparesetfield=--> SQLStateManager.prepareSetField(), name = {0}.
sqlstore.sqlstatemanager.preparetoupdateph1.exit=<-- SqlStateManager.prepareToUpdateI().
sqlstore.sqlstatemanager.preparetoupdateph1=--> SqlStateManager.prepareToUpdatePhaseI(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph2.exit=<-- SqlStateManager.prepareToUpdateII().
sqlstore.sqlstatemanager.preparetoupdateph2=--> SqlStateManager.prepareToUpdatePhaseII(), type = {0}.
sqlstore.sqlstatemanager.preparetoupdateph3.exit=<-- SqlStateManager.prepareToUpdateIII().
sqlstore.sqlstatemanager.preparetoupdateph3=--> SqlStateManager.prepareToUpdatePhaseIII(), type = {0}.
sqlstore.sqlstatemanager.prepareupdatefield.exit=<-- SQLStateManager.prepareUpdateField().
sqlstore.sqlstatemanager.prepareupdatefield=--> SQLStateManager.prepareUpdateField(), name = {0} for state: {1}.
sqlstore.sqlstatemanager.prepareupdatefieldspl.exit=<-- SQLStateManager.prepareUpdateFieldSpecial().
sqlstore.sqlstatemanager.prepareupdatefieldspl=--> SQLStateManager.prepareUpdateFieldSpecial, name = {0} for state: {1}.
sqlstore.sqlstatemanager.processcollectionupdate.exit=<-- SQLStateManager.processCollectionUpdates().
sqlstore.sqlstatemanager.processcollectionupdate=--> SQLStateManager.processCollectionUpdates(), beforeList={0}, afterlist={1}.
sqlstore.sqlstatemanager.processforeign=process foreign field ={0}.
sqlstore.sqlstatemanager.processforeignfield.remove=-- SQLStateManager.processForeignField(): was Collection - remove.
sqlstore.sqlstatemanager.processforeignfield.remove_from_bi=-- SQLStateManager.processForeignField(): is SCOCollection - remove from BI.
sqlstore.sqlstatemanager.processforeignfield.reset=-- SQLStateManager.processForeignField(): was SCOCollection - reset.
sqlstore.sqlstatemanager.processforeignfield=-- SQLStateManager.processForeignField(): value: {0} type: {1}.
sqlstore.sqlstatemanager.realizefield.exit=<-- SqlStateManager.realizeField().
sqlstore.sqlstatemanager.realizefield=--> SqlStateManager.realizeField(), name = {0}.
sqlstore.sqlstatemanager.realizeforeignfield.exit=<-- SqlStateManager.realizeField(), field realized = {0}.
sqlstore.sqlstatemanager.realizeforeignfield=--> SqlStateManager.realizeField(), name = {0}.
sqlstore.sqlstatemanager.recordingfield=recording field = {0}.
sqlstore.sqlstatemanager.refreshpersistent.exit=<-- SqlStateManager.refreshPersistent().
sqlstore.sqlstatemanager.refreshpersistent=--> SqlStateManager.refreshPersistence(), type = {0}.
sqlstore.sqlstatemanager.reload.exit=<-- SqlStateManager.reload(FieldDesc).
sqlstore.sqlstatemanager.reload=--> SqlStateManager.reload(FieldDesc), type = {0}, field = {1}.
sqlstore.sqlstatemanager.removeupdate=<-> SQLStateManager.removeUpdatedForeignReference(), lobj={0}, f={1}, fobj={2}, refCount={3}.
sqlstore.sqlstatemanager.replaceobjectfield.unsetsco=-- SqlStateManager.replaceObjectField(), unset SCO.
sqlstore.sqlstatemanager.replaceobjectfield=-- SqlStateManager.replaceObjectField(), field = {0}, type= {1}.
sqlstore.sqlstatemanager.reset=--> SqlStateManager.reset(), retValues = {0}, wasNew: {1}, keepState: {2}.
sqlstore.sqlstatemanager.resettingcollection=Resetting Collection.
sqlstore.sqlstatemanager.resettingdate=Resetting Date.
sqlstore.sqlstatemanager.resolvedependencies=<-> SQLStateManager.resolveDependencies(), obj={0}.
sqlstore.sqlstatemanager.resolvedependency=<-> SQLStateManager.resolveDependency(), dependency resolved: lobj={0}, f={1}, fobj={2}.
sqlstore.sqlstatemanager.retrieve.exit=<-- SqlStateManager.retrieve().
sqlstore.sqlstatemanager.retrieve=--> SqlStateManager.retrieve(), name = {0}.
sqlstore.sqlstatemanager.retrieveforeign.exit=<-- SqlStateManager.retrieveForeign().
sqlstore.sqlstatemanager.retrieveforeign=--> SqlStateManager.retrieveForeign(), name = {0}.
sqlstore.sqlstatemanager.unsetmask=unsetting masks for field = {0}.
sqlstore.sqlstatemanager.unconditionalreload.exit=<-- SqlStateManager.reload().
sqlstore.sqlstatemanager.unconditionalreload=--> SqlStateManager.reload(), type = {0}.
sqlstore.sqlstatemanager.updatebeforeimage=<-> SQLStateManager.updateBeforeImage(), name = {0}, value = {1}.
sqlstore.sqlstatemanager.updateobjfield.exit=<-- SQLStateManager.updateObjectField().
sqlstore.sqlstatemanager.updateobjfield=--> SQLStateManager.updateObjectField(), name = {0}, type = {1}.
sqlstore.sqlstatemanager.updatepersistent.exit=<-- SqlStateManager.updatePersistent().
sqlstore.sqlstatemanager.updatepersistent.immediateflush=<--> SqlStateManager.updatePersistent(), immediate flush required: obj={0}, next={1}.
sqlstore.sqlstatemanager.updatepersistent.skipped=<--> SqlStateManager.updatePersistent() skipped, type ={0}, obj= {1}.
sqlstore.sqlstatemanager.updatepersistent=--> SqlStateManager.updatePersistent(), type = {0}.
sqlstore.sqlstatemanager.updatetrackedfields.exit=<-- updateTrackedFields().
sqlstore.sqlstatemanager.updatetrackedfields=--> updateTrackedFields(), f = {0} value = {1}  fieldToIgnore = {2}.


###############################################################################
# <sql generator components: All the source files under sql.>
# Message ID Range: JDO76300 - JDO76399
###############################################################################
core.constraint.duporderby=JDO76300: A restri\u00e7\u00e3o \u00e9 um \"ordenar por\" para o campo {0} que j\u00e1 foi especificado em uma restri\u00e7\u00e3o \"ordenar por\".
core.constraint.fielddisallowed=JDO76301: O par\u00e2metro fieldName foi especificado, mas n\u00e3o \u00e9 permitido com a opera\u00e7\u00e3o {0}.
core.constraint.fieldrequired=JDO76302: O par\u00e2metro fieldName est\u00e1 faltando, mas a opera\u00e7\u00e3o {0} requer um campo.
core.constraint.illegalParameterInfo=JDO76303: addConstraint() para OP_PARAMETER precisa ser chamado com valor do tipo ParameterInfo.
core.constraint.illegalnode=JDO76304: N\u00f3 ilegal de restri\u00e7\u00e3o {0} na pilha SqlConstraint.
core.constraint.illegalop=JDO76305: O par\u00e2metro da opera\u00e7\u00e3o continha um valor ilegal de {0}.
core.constraint.needfieldnamenode=JDO76306: Erro na pilha de restri\u00e7\u00e3o. Um nome de campo \u00e9 esperado.
core.constraint.needfieldnode=JDO76307: Erro na pilha de restri\u00e7\u00e3o.  Uma descri\u00e7\u00e3o de campo \u00e9 esperada.
core.constraint.needvalnode=JDO76308: Erro na pilha de restri\u00e7\u00e3o.  Um valor \u00e9 esperado.
core.constraint.stackempty=JDO76309: A pilha de restri\u00e7\u00e3o est\u00e1 vazia -- valores insuficientes para o n\u00famero do operador.
core.constraint.unknownfield=JDO76310: O campo {0} especificado no descritor de recupera\u00e7\u00e3o n\u00e3o \u00e9 um membro da classe {1}.
core.constraint.valdisallowed=JDO76311: O par\u00e2metro de valor foi especificado, mas n\u00e3o \u00e9 permitido com a opera\u00e7\u00e3o {0}.
core.constraint.valrequired=JDO76312: O par\u00e2metro de valor est\u00e1 faltando, mas a opera\u00e7\u00e3o {0} requer um valor.
sqlstore.resultdesc.errorgettingvalefromresulset=JDO76313: Erro ao obter o valor do resultset no \u00edndice {0} como resultType {1}. columnSqlType {2}. Exce\u00e7\u00e3o: {3}
sqlstore.resultdesc.foreignfieldprojection=JDO76314: As consultas para {0} n\u00e3o deveriam ter proje\u00e7\u00f5es em um campo de relacionamento.
sqlstore.resultdesc.unknownfieldtype=JDO76317: Um tipo desconhecido de campo foi encontrado {0}.
sqlstore.retrievedesc.toomanyprojections=JDO76318: N\u00e3o \u00e9 poss\u00edvel definir mais de uma proje\u00e7\u00e3o para um RetrieveDesc.
sqlstore.retrievedesc.toomanyresulttypes=JDO76319: N\u00e3o \u00e9 poss\u00edvel definir mais de um tipo de resultado para um RetrieveDesc.
sqlstore.selectstatement.noupdatelocksupport=JDO76320: Um dos tipos de objetos envolvidos nesta consulta est\u00e1 no n\u00edvel de consist\u00eancia "bloquear quando carregado". For\u00e7ar este n\u00edvel de consist\u00eancia requer que o armazenador de dados suporte o bloqueio para atualizar no n\u00edvel da linha. O armazenador de dados n\u00e3o suporta o bloqueio para atualizar no n\u00edvel da linha.
sqlstore.sql.generator.statement.likeescapenotsupported=JDO76321: A cl\u00e1usula LIKE ESCAPE n\u00e3o possui suporte neste banco de dados.
sqlstore.sql.generator.statement.positionthreeargsnotsupported=JDO76322: Terceiro arg para a cl\u00e1usula POSITION precisa ser 1.
core.configuration.classnotmapped=JDO76323: A classe ''{0}'' n\u00e3o est\u00e1 mapeada.
core.configuration.classnotmappedtotable=JDO76324: A classe {0} n\u00e3o est\u00e1 mapeada para a tabela {1}.
sqlstore.sql.generator.statement.unexpectedconstraint=JDO76325: Uma restri\u00e7\u00e3o para a opera\u00e7\u00e3o {0} nunca pode ser a raiz de uma cl\u00e1usula Where.

# <I18N: sql generator>
# Following messages are used within other messages. They need to be i18ned but need not be numbered.
#
sqlstore.sql.generator.statement.sqlStatement=Declara\u00e7\u00e3o SQL
sqlstore.sql.generator.statement.withinputvalues= com valores de entrada:
sqlstore.sql.generator.statement.withnoinputvalues= sem valores de entrada:


#
# <ResultDesc NOI18N>
#
sqlstore.resultdesc.deserializing=deserializing = {0}.
sqlstore.resultdesc.marking_field=marking local field {0} as present.
sqlstore.resultdesc.marking_foreign_field=marking foreign field {0} as present.
sqlstore.resultdesc.marking_key_field=marking key field {0} as present.
sqlstore.resultdesc.returning_field=returning field {0} as projection.
#
# <Misc. SQLStore NOI18N >
#
sqlstore.sql.concurrency.concurrencychkdirty.exit=--> ConcurrencyCheckDirty.update().
sqlstore.sql.concurrency.concurrencychkdirty=--> ConcurrencyCheckDirty.update(), beforeImage = {0}.
sqlstore.sql.concurrencyoptverify.resumetx=<--> ConcurrencyOptVerify.resume(), resumed transaction = {0}.
sqlstore.sql.concurrencyoptverify.suspendtx=<--> ConcurrencyOptVerify.suspend(), suspended transaction = {0}.
sqlstore.sql.concurrencyoptverify.update.exit=<-- ConcurrencyOptVerify.update().
sqlstore.sql.concurrencyoptverify.update=--> ConcurrencyOptVerify.update(), beforeImage = {0}.
sqlstore.sql.generator.dbstatement.addbatch=addbatch ({0})
sqlstore.sql.generator.dbstatement.bindinputcolumn=bindInputColumn index: {0} value: {1} sqlType: {2}.
sqlstore.sql.generator.dbstatement.executebatch=executeBatch executing {0} command(s)
sqlstore.sql.generator.selectqueryplan.processforeignfield.exit=<-- SelectQueryPlan.processForeignFields().
sqlstore.sql.generator.selectqueryplan.processforeignfield=--> SelectQueryPlan.processForeignFields(), class = {0}.
sqlstore.sql.generator.selectqueryplan.processlocalfield.exit=<-- SelectQueryPlan.processLocalFields().
sqlstore.sql.generator.selectqueryplan.processlocalfield=--> SelectQueryPlan.processLocalFields(), class = {0}.
sqlstore.sql.generator.selectqueryplan.processstmts.exit=<-- SelectQueryPlan.processStatements().
sqlstore.sql.generator.selectqueryplan.processstmts=--> SelectQueryPlan.processStatements(), class = {0}, statements = {1}.
sqlstore.sql.updateobjdescimpl.afterimagenull=AfterImage is not set.
sqlstore.sql.updateobjdescimpl.beforeimagenull=BeforeImage is not set.
sqlstore.sql.updateobjdescimpl.markrelationshipchange=<--> UpdateDesc.markRelationshipChange().
sqlstore.sql.updateobjdescimpl.updated={0} is updated.


###############################################################################
# <SQLStoreManager>
# Message ID Range: JDO76400 - JDO76499
###############################################################################
#
# <SQLStoreManager>
#
core.persistencestore.jdbcerror=JDO76400: Obteve um JDBC SQLException ao executar a declara\u00e7\u00e3o SQL:\n{0}.\nExamine a SQLException para obter mais informa\u00e7\u00f5es.
sqlstore.retrievedesc.stmntsnotjoined=JDO76401: M\u00faltiplas declara\u00e7\u00f5es SQL n\u00e3o possuem suporte para um RetrieveDesc.
core.persistencestore.toofewrows=JDO76402: Menos linhas foram retornadas do banco de dados ao tentar obter o valor para a associa\u00e7\u00e3o {1} da classe {0} do que permite a cardinalidade desta associa\u00e7\u00e3o.  O n\u00famero m\u00ednimo de linhas permitido \u00e9 de {2}.
core.persistencestore.toomanyobjforcard1=JDO76403: O banco de dados n\u00e3o \u00e9 consistente com o modelo persistente.  Uma tentativa de recuperar o objeto referenciado pela {1} associa\u00e7\u00e3o de itens da {0} classe recuperada {2} , mas somente 1 item pode ser acomodado j\u00e1 que o limite superior da cardinalidade para a associa\u00e7\u00e3o \u00e9 1.
core.persistencestore.toomanyrows=JDO76405: Mais linhas foram retornadas do banco de dados ao tentar obter o valor para a associa\u00e7\u00e3o {1} da classe {0} do que permite a cardinalidade desta associa\u00e7\u00e3o.  O n\u00famero m\u00e1ximo linhas permitido \u00e9 de {2}.
core.store.concurrentaccess=JDO76406: Exce\u00e7\u00e3o de acesso concorrente: o objeto para {0} foi atualizado ou exclu\u00eddo por outra transa\u00e7\u00e3o.
sqlstore.sqlstoremanager.errorcloseresultset=JDO76407: Erro ao fechar o conjunto de resultados SQL. Exce\u00e7\u00e3o : {0}
sqlstore.sqlstoremanager.errorclosestatement=JDO76408: Erro ao fechar a declara\u00e7\u00e3o SQL. Exce\u00e7\u00e3o : {0}
sqlstore.sql.generator.selectqueryplan.plansnotjoined=JDO76409: M\u00faltiplos planos de consulta n\u00e3o possuem suporte para um RetrieveDesc.

#
# <NOI18N: SQLStoreManager>
#
sqlstore.sqlstoremanager.executeQuery.exit=<-- SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeQuery=--> SQLStoreManager.executeQuery().
sqlstore.sqlstoremanager.executeupdate.exit=<-- SQLStoreManager.executeUpdate(), rows affected = {0}.
sqlstore.sqlstoremanager.executeupdate=--> SQLStoreManager.executeUpdate().
sqlstore.sqlstoremanager.executeupdatebatch.addbatch={0}; add batch.
sqlstore.sqlstoremanager.executeupdatebatch.exit=<-- SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.executeupdatebatch.exit.flush=<-- SQLStoreManager.executeUpdateBatch(), rows affected = {0}.
sqlstore.sqlstoremanager.executeupdatebatch.flushbatch={0}; flush batch.
sqlstore.sqlstoremanager.executeupdatebatch=--> SQLStoreManager.executeUpdateBatch().
sqlstore.sqlstoremanager.getpersistenceconfig=<--> SQLStoreManager.getPersistenceConfig(), classType = {0}.
sqlstore.sqlstoremanager.selectnoncorrelated.exit=<-- SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.selectnoncorrelated=--> SQLStoreManager.selectNonCorrelated().
sqlstore.sqlstoremanager.vendortype=<--> SQLStoreManager: vendor type = {0}.


###############################################################################
# <Connection/Connectionpool/DBVendorType/TransactionImpl/OracleSpecialDBOperation>
# Message ID Range: JDO76500 - JDO76599
###############################################################################
#
# <Connection/Connection Pool> - database
#
connection.connectionmanager.badnew=JDO76500: Novo ''{0}'' precisa ser maior ou igual ao atual ''{1}''.
connection.connectionmanager.badvalue=JDO76501: Valor inv\u00e1lido para ''{0}''.
connection.connectionmanager.conntimeout=JDO76502: Tempo de conex\u00e3o expirado.
connection.connectionmanager.getconnection.mismatch=JDO76503: A conex\u00e3o de conjunto n\u00e3o tem o mesmo contexto de usu\u00e1rio.
connection.connectionmanager.isdown=JDO76504: O Gerenciador de conex\u00e3o est\u00e1 sendo fechado.
connection.connectionmanager.maxpool=JDO76505: O conjunto de conex\u00e3o est\u00e1 no m\u00e1ximo.
connection.connectionmanager.msintervalvalue=JDO76506: MsInterval precisa ser maior do que zero e menor ou igual a MsWait.
connection.connectionmanager.mswaitvalue=JDO76507: MsWait precisa ser maior ou igual a zero.
connection.connectionmanager.nulldriver=JDO76508: Valor NULO para o Nome do Driver.
connection.connectionmanager.nullurl=JDO76509: Valor NULO para o URL.
connection.connectionmanager.poolsize=JDO76510: 'maxPool' precisa ser maior ou igual a 'minPool'.
connection.connectionmanager.threaditerupted=JDO76511: Segmento interrompido.
connection.connectionmanager.zero=JDO76512: ''{0}'' precisa ser maior ou igual a zero.
#
# <DBVendorType>
#
sqlstore.database.dbvendor.cantloadDefaultProperties=JDO76513: N\u00e3o \u00e9 poss\u00edvel carregar as propriedades para o banco de dados padr\u00e3o.
sqlstore.database.dbvendor.init.default=JDO76514: -->N\u00e3o foi poss\u00edvel carregar a propriedade para o tipo de fornecedor {0}. Os padr\u00f5es ser\u00e3o utilizados.
sqlstore.database.dbvendor.cantinstantiateclass=JDO76515: Falha ao instanciar a classe {0}.
#
# <OracleSpecialDBOperation>
#
sqlstore.database.oracle.defineCol=JDO76516: Falha ao definir a coluna para a declara\u00e7\u00e3o.
sqlstore.database.oracle.nooracleavailable=JDO76517: Ao inicializar a f\u00e1brica de recursos Oracle ''{0}'', houve uma falha em obter um inst\u00e2ncia do oracle.jdbc.OraclePreparedStatement ou do oracle.jdbc.driver.OraclePreparedStatement. A otimiza\u00e7\u00e3o espec\u00edfica do Oracle ser\u00e1 desativada. Se as inst\u00e2ncias que utilizam este recurso necessitam de valores vincul\u00e1veis para colunas mapeadas para a coluna Fixed Char, os valores ser\u00e3o preenchidos com espa\u00e7os para o comprimento especificado no arquivo dbschema correspondente.
sqlstore.database.oracle.fixedcharpadded=JDO76518: O valor "{0}" est\u00e1 vinculado com uma coluna CHAR. Isso requer o manuseio especial no Oracle. Como a classe OraclePreparedStatement n\u00e3o p\u00f4de ser obtida do driver, o valor \u00e9 preenchido com espa\u00e7os no comprimento {1}, como especificado no arquivo dbschema capturado.
#
# <Misc.>
#
core.configuration.getvendortypefailed=JDO76519: Falha em identificar o tipo de fornecedor para o armazenador de dados.
jdo.sqlpersistencemanagerfactory.errorgettingDatabaseInfo=JDO76520: Erros ao obter informa\u00e7\u00f5es sobre o banco de dados. Obteve a seguinte exce\u00e7\u00e3o:

#
# <NOI18N: Connection>
#
sqlstore.connection.conncectiomgr.found=<--> ConnectionManager.getConnection: found {0}.
sqlstore.connection.conncectiomgr.getnewconn=<--> ConnectionManager.getConnection: new {0}.
sqlstore.connection.conncectiomgr.replacefreeconn=<--> ConnectionManager.replaceFreeConnection: free {0}.
sqlstore.connectionimpl.clearxact.close=--- ConnectionImpl.clearXact: connection closed .
sqlstore.connectionimpl.clearxact.disassocxact=--- ConnectionImpl.clearXact: disassociateXact .
sqlstore.connectionimpl.clearxact=--- ConnectionImpl.clearXact: .
sqlstore.connectionimpl.close.connrelease=<--- ConnectionImpl.close: connection released.
sqlstore.connectionimpl.close.exit=<--- ConnectionImpl.close: connection closed.
sqlstore.connectionimpl.close.freepending=<--- ConnectionImpl.close: set FreePending.
sqlstore.connectionimpl.close.putfreelist=<--- ConnectionImpl.close: put in freeList.
sqlstore.connectionimpl.close.replaced=<--- ConnectionImpl.close: connection replaced.
sqlstore.connectionimpl.close=---> ConnectionImpl.close.
sqlstore.connectionimpl.close_arg=---> ConnectionImpl.close: {0}.
sqlstore.connectionimpl.commit=--- ConnectionImpl.commit: connection closed.
sqlstore.connectionimpl.finalize=--- ConnectionImpl.finalize: connection closed.
sqlstore.connectionimpl.internalcommit=--- ConnectionImpl.internalCommit: .
sqlstore.connectionimpl.pendingdisassocxact=--- ConnectionImpl.clearXact: Pending disassociateXact.
sqlstore.connectionimpl.rollback.close=--- ConnectionImpl.rollback: connection closed.
sqlstore.connectionimpl.rollback=--- ConnectionImpl.rollback:.
#
# <NOI18N: DBVendorType>
#
sqlstore.database.dbvendor.castRequiredForNumericValues=<-> DBVendorType.isCastRequiredForNumericValues(): {0}.
sqlstore.database.dbvendor.getModFunctionName=<-> DBVendorType.getModFunctionName(): {0}.
sqlstore.database.dbvendor.getNullComparisonFunctionName=<-> DBVendorType.getNullComparisonFunctionName(): {0}.
sqlstore.database.dbvendor.getConcatCast=<-> DBVendorType.getConcatCast(): {0}.
sqlstore.database.dbvendor.getSpecialDBOperation=<-> DBVendorType.getSpecialDBOperation(): {0}.
sqlstore.database.dbvendor.getabs=<-> DBVendorType.getAbs(): {0}.
sqlstore.database.dbvendor.getcharlength=<-> DBVendorType.getCharLength(): {0}.
sqlstore.database.dbvendor.getforupdate=<-> DBVendorType.getForUpdate(): {0}.
sqlstore.database.dbvendor.getholdlock=<-> DBVendorType.getHoldlock(): {0}.
sqlstore.database.dbvendor.getisnotnull=<-> DBVendorType.getIsNotNull(): {0}.
sqlstore.database.dbvendor.getisnull=<-> DBVendorType.getIsNull(): {0}.
sqlstore.database.dbvendor.getleftjoin=<-> DBVendorType.getLeftJoin(): {0}.
sqlstore.database.dbvendor.getleftjoinpost=<-> DBVendorType.getLeftJoinPost(): {0}.
sqlstore.database.dbvendor.getleftlikeescape=<-> DBVendorType.getLeftLikeEscape(): {0}.
sqlstore.database.dbvendor.getnotequal=<-> DBVendorType.getNotEqual(): {0}.
sqlstore.database.dbvendor.getposition3args=<-> DBVendorType.getPositionThreeArrgs(): {0}.
sqlstore.database.dbvendor.getposition=<-> DBVendorType.getPosition(): {0}.
sqlstore.database.dbvendor.getpositionin=<-> DBVendorType.getPositionIn(): {0}.
sqlstore.database.dbvendor.getpositionsrchsrc=<-> DBVendorType.getPositionSearchSource(): {0}.
sqlstore.database.dbvendor.getquotecharstart=<-> DBVendorType.getQuoteCharStart(): {0}.
sqlstore.database.dbvendor.getrightjoinipre=<-> DBVendorType.getRightJoin(): {0}.
sqlstore.database.dbvendor.getrightlikeescape=<-> DBVendorType.getRightLikeEscape(): {0}.
sqlstore.database.dbvendor.getrtrim=<-> DBVendorType.getRtrim(): {0}.
sqlstore.database.dbvendor.getrtrimpost=<-> DBVendorType.getRtrimPost(): {0}.
sqlstore.database.dbvendor.getsqrt=<-> DBVendorType.getSqrt(): {0}.
sqlstore.database.dbvendor.getstringconcat=<-> DBVendorType.getStringConcat(): {0}.
sqlstore.database.dbvendor.getsubstring=<-> DBVendorType.getSubstring(): {0}.
sqlstore.database.dbvendor.getsubstringfor=<-> DBVendorType.getSubstringFor(): {0}.
sqlstore.database.dbvendor.getsubstringfrom=<-> DBVendorType.getSubstringFrom(): {0}.
sqlstore.database.dbvendor.gettablelistend=<-> DBVendorType.getTableListEnd(): {0}.
sqlstore.database.dbvendor.gettableliststart=<-> DBVendorType.getTableListStart(): {0}.
sqlstore.database.dbvendor.isAnsiTrim=<-> DBVendorType.isAnsiTrim(): {0}.
sqlstore.database.dbvendor.isInlineNumeric=<-> DBVendorType.isInlineNumeric(): {0}.
sqlstore.database.dbvendor.isNativeOuterJoin=<-> DBVendorType.isNativeOuterJoin(): {0}.
sqlstore.database.dbvendor.isParameterCast=<-> DBVendorType.isParameterCast(): {0}.
sqlstore.database.dbvendor.isdistinctupdatelocksupported=<-> DBVendorType.isDistinctSupportedWithUpdateLock(): {0}.
sqlstore.database.dbvendor.islockcolumnlistsupported=<-> DBVendorType.isLockColumnListSupported(): {0}.
sqlstore.database.dbvendor.isupdatelocksupported=<-> DBVendorType.isUpdateLockSupported(): {0}.
sqlstore.database.dbvendor.mapemptystrtonull=<-> DBVendorType.mapEmptyStringToNull(): {0}.
sqlstore.database.dbvendor.overrideproperties.with=<-> DBVendorType.overrideProperties() : {0} with: {1}.
sqlstore.database.dbvendor.overrideproperties=<-> DBVendorType.overrideProperties() - NONE.
sqlstore.database.dbvendor.supportslikeescape=<-> DBVendorType.supportsLikeEscape(): {0}.
sqlstore.database.dbvendor.vendorname=<-> DBVendorType(), vendorName: [{0}]  vendorType: {1}.
#
# <NOI18N: TransactionImpl>
#
sqlstore.transactionimpl.call.info={0} Tran[ {1} ].{2}: {3} for  {4}.
sqlstore.transactionimpl.call={0} Tran[ {1} ].{2}:status = {3}, txType: {4} for  {5}.
sqlstore.transactionimpl.closeconnection=--- TransactionImpl.closeConnection() {0} for {1}.
sqlstore.transactionimpl.general={0}.
sqlstore.transactionimpl.getconnection=--- TransactionImpl.getConnection(): {0} TX optimistic: {1} referenceCount = {2} for {3}.
sqlstore.transactionimpl.releaseconnection=--- TransactionImpl.releaseConnection(): TX optimistic: {0} Inside Commit: {1} referenceCount: {2} for {3}.
sqlstore.transactionimpl.rollbackconnection=--- TransactionImpl.rollbackConnection(): {0} for {1}.
sqlstore.transactionimpl.status={0} Tran[ {1} ].setStatus: {2} => {3} for {4}.


###############################################################################
# All the source files under subdir ejb.
# Message ID Range: JDO76600 - JDO76699
###############################################################################
#
#EJBHelper messages
#
# {0} - method name
ejb.ejbhelper.nonmanaged=JDO76600: O m\u00e9todo {0} n\u00e3o deveria ser chamado em um ambiente n\u00e3o-gerenciado.

#
# Common messages between SunContainerHelper and DeploymentHelper
# so they have a neutral key, that still starts with "ejb".
#
# {0} - jndi name.
ejb.jndi.lookupfailed=JDO76604: Falha da pesquisa JNDI para cmp-resource ''{0}''.
JDO76604.diag.cause.1=O recurso CMP com este nome JNDI n\u00e3o est\u00e1 registrado com esta inst\u00e2ncia.
JDO76604.diag.cause.1=O nome JNDI para o recurso CMP tem erro de ortografia.
JDO76604.diag.check.1=Verifique o nome JNDI para o recurso que planeja utilizar.
JDO76604.diag.check.2=Verifique o nome JNDI do recurso CMP especificado no m\u00f3dulo.

# {0} - jndi name.
# {1} - returned class name.
ejb.jndi.unexpectedinstance=JDO76605: A pesquisa JNDI para o cmp-resource ''{0}'' retornou uma inst\u00e2ncia de tipo inesperado: {1}.
JDO76605.diag.cause.1=O recurso CMP com este nome JNDI n\u00e3o referencia o jdbc-resource ou o persistence-manager-factory-resource.
JDO76604.diag.cause.1=O nome JNDI para o recurso CMP tem erro de ortografia.
JDO76604.diag.check.1=Verifique o nome JNDI para o recurso que planeja utilizar.
JDO76604.diag.check.2=Verifique o nome JNDI do recurso CMP especificado no m\u00f3dulo.

#
# DeploymentHelper messages - ejb
#
#
#<NOI18N: DeploymentHelper>
#
ejb.DeploymentHelper.getconnection=Getting connection for JNDI name ''{0}''.

# The messages JDO76606 through JDO76615 that were originally here 
# have been moved to 
# cmp/support/ejb/src/com/sun/jdo/spi/persistence/support/ejb/ejbc/Bundle.properties
# As part of INF#
# So do not use these messages. 


#
#CMPHelper messages
#
ejb.cmphelper.nonmanaged=JDO76613: Acesso inv\u00e1lido do CMPHelper. Esta classe \u00e9 usada somente para o suporte CMP e n\u00e3o deveria ser chamada fora de um servidor de aplicativo.

#
#SunTransactionHelper messages
#

# {0} class name
ejb.SunTransactionHelper.wrongdatasourcetype=JDO76616: O DataSource n\u00e3o \u00e9 do tipo esperado. Esperado: com.sun.appserv.jdbc.DataSource, obteve: {0}.


###############################################################################
# <Generic messages. Add new messages to this section only if none of the above categories can be used.>
###############################################################################
#
# <NOI18N: generic>
#
vendor=Sun Microsystems
# majorVersion (minorVersion) buildDate
fullVersion={0} ({1}) {2}
#
# <NOI18N: This messages are used for JDOFatalInternalException from multiple places. No need to I18N>
#
core.generic.unknownfield=The field {0} is not a member of the class {1}.
core.generic.unknownexception=Got an unknown exception.
core.generic.nullparam=The {0} parameter is null.
core.generic.notinstanceof=The object of class {0} is not an instance of {1}.


###############################################################################
# <These messages are used from multiple places in code.It is absolutely necessary to cleanup code
# to use different messages >
###############################################################################
core.configuration.cantloadclass=Falha ao carregar a classe {0}.
sqlstore.exception.log=Exce\u00e7\u00e3o.
jdo.lifecycle.deleted.accessField=N\u00e3o \u00e9 poss\u00edvel acessar o campo de uma inst\u00e2ncia exclu\u00edda.
